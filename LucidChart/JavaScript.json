{"JavaScript":{
	"environment dependence":{},
	"common":{
		"ECMASrript":{
			"distinguish between upper and lowercase letters":{},
			"have reserved word":{},
			"separate sentence by semicoron":{},
			"strict mode":{},
			"execute context":{
                "Script":{},
				"Module":{}
			},
			"comment":{
				"line comment":{},
				"multiple line comment":{},
				"HTML-like comment":{
					"use":{
						"backward compatibility":{}
					}
				}
			},
			"variables and declarations":{
				"const":{
					"resubstitution":{
						"enable":"false"
					},
					"initial value":{
						"required":"true"
					},
					"same name valiables":{
						"enable":"false"
					}
				},
				"let":{
					"resubstitution":{
						"enable":"true"
					},
					"initial value":{
						"required":"false",
						"undefined initial value":"undefined"
					},
					"same name valiables":{
						"enable":"false"
					}
				},
				"var":{
					"resubstitution":{
						"enable":"true"
					},
					"initial value":{
						"required":"false",
						"undefined initial value":"undefined"
					},
					"same name valiables":{
						"enable":"true",
						"problem":{
							"replace value":{},
							"hoisting":{}
						}
					}
				}				
			},
			"value evaluation and display":{
				"evaluation result":{
					"display":{
						"console display":{
							"evaluation operand":{},
							"error":{
								"SyntaxError":{
									"type":"SyntaxError",
									"discription":{},
									"filename:linenumber:columnumber":{}
								},
								"RunTimeError":{
									"ReferenceError":{
										"type":"ReferenceError",
										"what is not defind":{},
										"filename:linenumber:columnumber":{}
									}
								},
								"TypeError":{}
							}
						}
					}
				}
			},
			"data type and literal":{
				"data type":{
					"primitive":{
						"mutability":"immutable",
						"Boolean data type":"true or false",
						"Number data type":{
							"real number":{
								"integer":["decimal number", "binary number", "octal number", "hexadecimal number"]
							},
							"decimal":{}
						},
						"String data type":{
							"expression":"string",
							"line feed expression":{
									"line feed escape character":"\n"
							},
							"template":{
								"expression":"string",
								"defind variable notation":"${str}",
								"line feed notation":"enter(line feed code)"
							}
						},
						"undefind data type":"value id not defind",
						"null data type":"value is not exist expicitly",
						"Symbol data type":{
							"notation":"variable = Symbol()",
							"notation synbol's explain":"Synbol(explain)"
						}
					},
					"object data type":{
						"non primitive data":{
							"mutability":"mutable",
							"object":{
								"notation":"key:value",
								"key named in object":"property",
								"data type of key":["string", "synbol"],
								"data type of value":"any defined data type is ok",
								"reference value":{
									"dot notation":{
										"notation":"object identifier.propertie identifier",
										"ristrict to use":"property required to be identifier"
									},
									"brachet notation":{
										"notation":"object identifire[propertie name]"
									}
								},
								"wrapper object":{
									"string wrapper object":{},
									"number wrapper object":{},
									"boolean wrapper object":{}
								}
							},
							"array":{
								"order of value":{
									"index number of order":"[index0, index1, index2, ...]"
								},
								"reference value":{
									"notation":"array identifire[index number]"
								}
							},
							"function":{},
							"regurar expression":{},
							"etc...":{}
						}
					}
				},
				"data type cheching operator":"typeof",
				"literal":{
					"wahat is the literal":"meta infomation for define data type",
					"notation of literal":{
						"String literal":["\"\"", "single quote"],
						"Number literal":{
							"integer":{
								"decimal number":"integer without decoration",
								"binary number":"0b",
								"octal number":{
									"0o":{
										"strict mode":"enable"
									},
									"0":{
										"strict mode":"disable"
									}
								},
								"hexadecimal number":"0x"
							}
						},
						"Boolean literal":["true", "false"],
						"null literal":"null",
						"object literal":"{}",
						"array literal":"[]",
						"regular expression literal":"\/\/",
						"template literal":"back quote"
					}
				}

			},
			"operator":{
				"binary operator":{
					"plus operator":{
						"function":{
							"Number data type":"add two operand" 
						},
						"notation":"operand + operand"
					},
					"string concatenation operand":{
						"function":{
							"String data type":"join two operand"
						},
						"notation":"operand + operand"
					},
					"minus operator":{
                        "function":{
                            "Number data type":"take a operand from a operand"
                        },
                        "notation":"operand - operand"
                    },
                    "multiplication operator":{
                        "function":{
                            "Number data type":"a operand multiply a operand"
                        },
                        "notation":"operand * operand"
                    },
                    "division operator":{
                        "function":{
                            "Number data type":"a operand divided by a operand"
                        },
                        "notation":"operand / operand"
                    },
                    "surplus operator":{
                        "function":{
                            "Number data type":"surplus by divided two operand"
                        },
                        "notation":"operand % operand"
                    },
                    "exponentiation operator":{
                        "function":{
                            "Number data type":"a operand to the power of a operand"
                        },
                        "notation":{
                            "use exponentiation operator":"operand ** operand",
                            "use method":"Math.pow(operand, operand)"
                        }
                    }
                },
                "unary operator":{
                    "unary plus operator":{
                        "function":{
                            "Number data type":"convert to same operand",
                            "String data type":{
                                "enable to convert to numerical value":"convert to numerical value",
                                "disable to convert to numerival value":{
                                    "convert to":"NaN",
                                    "original name of NaN":"Not-a-Number",
                                    "evaluation about NaN":{
                                        "formula and result":{
                                            "use comparison operator":"console.log(NAN === NAN)=> false",
                                            "use method":{
                                                "use typeof":"console.log(typeof NaN) => number",
                                                "use Number.isNaN(NaN)":"console.log(Number.isNaN(NaN)) => true"
                                            }
                                        }
                                    },
                                    "usual conversion regime":"use Number constructer function or parseInt function"
                                }
                            }
                        },
                        "notation":"+operand"
                    },
                    "unary minus operator":{
                        "function":{
                            "Number data type":"convert to minus numerical value",
                            "String data type":{
                                "enable to convert to numerical value":"convert to minus numerical value",
                                "disable to convert to numerival value":{
                                    "a value converted to":"NaN"
                                }
                            }
                        },
                        "notation":"-operand"
                    },
                    "increment operator":{
                        "function":{
							"Number data type":"a operand plus 1",
							"String data type":{
                                "enable to convert to numerical value":"a operand convert to numerical value and plus 1",
                                "disable to convert to numerival value":{
                                    "convert to":"NaN"
                                }
                            }
						},
						"notation":{
							"prepositional":"++operand",
							"postpositional":"operand++"
						},
						"evaluation":{
							"prepositional":{
								"1st evaluation":"operand + 1",
								"2nd evaluation":"return evaluation result"
							},
							"postpositional":{
								"1st evaluation":"return ebaluation result",
								"2nd evaluation":"operand + 1"
							}
						}
					},
					"decrement operator":{
                        "function":{
							"Number data type":"a operand minus 1",
							"String data type":{
                                "enable to convert to numerical value":"convert to numerical value and minus 1",
                                "disable to convert to numerival value":{
                                    "convert to":"NaN"
                                }
                            }
						},
						"notation":{
							"prepositional":"--operand",
							"postpositional":"operand--"
						},
						"evaluation":{
							"prepositional":{
								"1st evaluation":"operand - 1",
								"2nd evaluation":"return evaluation result"
							},
							"postpositional":{
								"1st evaluation":"return ebaluation result",
								"2nd evaluation":"operand - 1"
							}
						}
                    }
				},
				"strict equal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are same data type and same value, return true",
						"String data type":"operator compaires two operands and if operands are same data type and same value, return true",
						"Object data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"Operands is Null data type":"return true",
						"Operands is Undefined":"return true",
						"Null and Undefined":"operator return false",
						"defference data type":"operator return false"
					},
					"notation":"operand === operand"
				},
				"strict inequal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are different data type or different value, return true",
						"String data type":"operator compaires two operands and if operands are different data type or different value, return true",
						"Object data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"Operands is Null data type":"return false",
						"Operands is Undefined":"return false",
						"Null and Undefined":"operator return true",
						"defference data type":"operator return true"
					},
					"notation":"operand !== operand"
				},
				"equal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are same value, return true",
						"String data type":"operator compaires two operands and if operands are same value, return true",
						"Object data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"defference data type":{
							"Number and String":{
								"enable to convert string to numerical value":"operator convert string value to numerical value and compaires number data type values",
								"disable to convert string to numerival value":"operator return false"
							},
							"Number and Boolean":{
								"boolean data type value is true":"operator convert boolean value to number data type 1 and compaires values",
								"boolean data type value is false":"operator convert boolean value to number data type 0 and compaires values"
							},
							"String and Boolean":{
								"enable to convert string to numerical value":{
									"boolean data type value is true":"operator convert string value to numerical value and convert boolean value to 1 compaires number data type values",
									"boolean data type value is false":"operator convert string value to numerical value and convert boolean value to 0 compaires number data type values"
								},
								"disable to convert string to numerival value":"operator return false"
							},
							"Null and Number":"operator return false",
							"Null and Boolean":"operator return false",
							"Null and String":"operator return false",
							"Undefined and Number":"operator return false",
							"Undefined and Boolean":"operator return false",
							"Undefined and String":"operator return false",
							"Null and Undefined":"operator return true"
						}
					},
					"notation":"operand == operand"
				},
				"inequal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are difference value, return true",
						"String data type":"operator compaires two operands and if operands are difference value, return true",
						"Object data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"defference data type":{
							"Number and String":{
								"enable to convert string to numerical value":"operator convert string value to numerical value and compaires number data type values",
								"disable to convert string to numerival value":"operator return true"
							},
							"Number and Boolean":{
								"boolean data type value is true":"operator convert boolean value to number data type 1 and compaires values",
								"boolean data type value is false":"operator convert boolean value to number data type 0 and compaires values"
							},
							"String and Boolean":{
								"enable to convert string to numerical value":{
									"boolean data type value is true":"operator convert string value to numerical value and convert boolean value to 1 compaires number data type values",
									"boolean data type value is false":"operator convert string value to numerical value and convert boolean value to 0 compaires number data type values"
								},
								"disable to convert string to numerival value":"operator return true"
							},
							"Null and Number":"operator return true",
							"Null and Boolean":"operator return true",
							"Null and String":"operator return true",
							"Undefined and Number":"operator return true",
							"Undefined and Boolean":"operator return true",
							"Undefined and String":"operator return true",
							"Null and Undefined":"operator return false",
							"String and String":"unknown"
						}
					},
					"notation":"operand != operand"
				},
				"greater or lesser operators":{
					"common function":{
						"Number and String":{
							"enable to convert string to numerical value":"operator convert string value to numerical value and compaires number data type values",
							"disable to convert string to numerival value":"operator return false"
						},
						"Number and Boolean":{
							"boolean data type value is true":"operator convert boolean value to number data type 1 and compaires values",
							"boolean data type value is false":"operator convert boolean value to number data type 0 and compaires values"
						},
						"String and Boolean":"operator return false",
						"Null and Number":{
							"number is not 0":"operator return result to compaire a number data type operand and 0",
							"number is 0":"operator return false"
						},
						"Null and Boolean":{
							"boolean data type value is true":"operator convert boolean to 1 and null to 0, then operator compaires numerical values",
							"boolean data type value is false":"operator return false"
						},
						"Null and String":{
							"enable to convert string to numerical value":{
								"number is not 0":"operator convert string value to numerical value and null to 0, then operator compaires number data type values",
								"number is 0":"operator return false"			
							},
							"disable to convert string to numerival value":"operator return false"
						},
						"Undefined and Number":"operator return false",
						"Undefined and Boolean":"operator return false",
						"Undefined and String":"operator return false",
						"Null and Undefined":"operator return false"
					},
					"greater operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is greater than right operand, return true"
						},
						"notation":"operand > operand"
					},
					"greater equal operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is greater than right operand, else if operands is same, return true"
						},
						"notation":"operand >= operand"
					},
					"lesser operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is lesser than right operand, return true"
						},
						"notation":"operand < operand"
					},
					"lesser equal operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is lesser than right operand, else if operands is same, return true"
						},
						"notation":"operand <= operand"
					}
				},
				"bitwise operators":{
					"common function":{
						"Number data type":{
							"round down left edge bit over 32bit":{
								"mantissa of operand is or less than 32bit":"operator convert operand",
								"mantissa of operand is more than 32bit":"operator round down left edge bit over 32bit"
							},
							"conversion":{			
								"positive number":"operator convert double precision floating point number operand to Signed 32-bit integer",
								"negative number":"operator convert absolute value of double precision floating point number operand to Signed 32-bit integer then, convert twos complement of 32bit integer type operand",
								"zero":"operator convert double precision floating point number filled 0"
							},
							"return value":{
								"do not flip a left edge bit by bitwise operation after 32bit conversion":"operator return decimal value of Number data type converted from 32 bits interpreted binary number",
								"flip a left edge bit to 1 from 0 by bitwise operation after 32bit conversion":"operator return minus decimal value of Number data type that converted from twos complement of 32 bits interpreted binary number"
							},
							"value range":{
								"in -2147483648 ~ 2147483647, -0b10000000000000000000000000000000 ~ 0b01111111111111111111111111111111":"positive or negative",
								"in 2147483648 ~ 4294967295, or 0b10000000000000000000000000000000 ~ 0b11111111111111111111111111111111":"absolutry positive number",
								"in -4294967295 ~ -2147483649 or -0b11111111111111111111111111111111 ~ -0b10000000000000000000000000000001":"absolutry positive number"
							}
						}
					},
					"Bitwise AND operator":{
						"function":{
							"Number data type":{
								"two operands are 1":"operator return 1",
								"two operands are not 1":"operator return 0"
							}
						},
						"use":{
							"bitwise mask with 0":{
								"operate operand with 0":"operator return 0",
								"operate operand with 1":"operator return operand as it is"
							}
						},
						"notation":"operand & operand"
					},
					"Bitwise OR operator":{
						"function":{
							"Number data type":{
								"two operands are 0":"operator return 0",
								"two operands are not 0":"operator return 1"
							}
						},
						"use":{
							"bitwise mask with 1":{
								"operato operand with 0":"operator return operand as it is",
								"operate operand with 1":"operator return 1"
							},
							"Additive color mixture":{}
						},
						"notation":"operand | operand"
					},
					"Bitwise XOR operator":{
						"function":{
							"Number data type":{
								"two operands are same":"operator return 1",
								"two operands are different":"operator return 0"
							}
						},
						"use":{
							"bit flip":{
								"operato operand with 0":"operator return flipped operand",
								"operate operand with 1":"operator return operand as it is"
							},
							"Additive color mixture":{}
						},
						"notation":"operand ^ operand"
					},
					"Bit nagation operator":{
						"function":{
							"Number data type":"operator return flipped operand"
						},
						"use":{
							"bit flip":{
								"operato operand with 0":"operator return flipped operand",
								"operate operand with 1":"operator return operand as it is"
							},
							"convert -1 to 0":{
								"String.indexOf() in if statement":{
									"why use bit nagation operator":"if can not find string, indexOf method return -1, in if statement, 0 treat as false and other than 0 true so notate concisely ",
									"notation":"if(~str.indexOf(?)) { }",
									"alter notation 1":"if(str.indexOf(?) !== -1) { }",
									"alter notation 2":"if(str.includes(?)) { }  //includes method retern false if can not find string so do not need ~"
								}
							}
						},
						"notation":"~operator"
					},
					"Left shift operator":{
						"function":"operator shift operand by argument bit toward left and round down flow bit at left, and add 0 at right",
						"returned value":"if right edge bit is 1, return minus decimal number converted from twos comprement of 32bit integer value",
						"notation":"operand << bit"
					},
					"Right shift operator":{
						"function":"operator shift operand by argument bit toward right and round down flow bit at right, and add bit value that is same as right edge bit value",
						"returned value":"if right edge bit is 1, return minus decimal number converted from twos comprement of 32bit integer value",
						"notation":"operand >> bit"
					},
					"Zero-fill right shift operator":{
						"function":"operator shift operand by argument bit toward right and round down flow bit at right, and add 0 bit",
						"notation":"operand >>> bit"
					},
					"Assignment operator":{
						"function":"operator assign value to variable",
						"notation":"variable = value",
						"use with binary operator":{
							"function":"operator assingn a result value operated operand by binary operator to variable",
							"notation":"binary operator =",
							"example notation":"+=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=,|="
						},
						"Destructuring assignment":{
							"Array":{
								"function":"operator assingn right operand array element value to left operand array element to have correspond index",
								"notation":"array operand = array operand"
							},
							"Object":{
								"function":"operator assingn right operand object element value to left operand array element to have correspond property",
								"notation":"object operand = object operand"
							}
						},
						"Ternary operator":{
							"function":{
								"Ecaluation result of conditional is true":"operator return evaluation result of left formula",
								"Ecaluation result of conditional is false":"operator return evaluation result of right formula"
							},
							"notation":"variable = conditional formula operand ? left formula operand : right formula operand",
							"use":{
								"change Initial value of variable by condition":{
									"alter notation":{
										"if statement":{
											"notation":"let variable; if(conditional formula) {variable = left formula}, else {variable = right formula}"
										}
									}
								}
							}
						}
					},
					"Boolean operator":{
						"AND operator":{
							"function":{
								"operands are true":"operator return true",
								"operands are not true":{
									"left operand is false":"operator return false, operator do not evaluate right operand",
									"left operand is true":{
										"right operand is false":"operator return false",
										"right operand is number":"operand return left operand number"
									},
									"left operand is number data type 0":"operand retun 0",
									"left operand is number data type other than 0":"left operand return true, and operator operate"
								}
							},
							"notation":"operand && operand"
						},
						"OR operator":{
							"function":{
								"operands are false":"operator return false",
								"operands are not false":{
									"left operand is true":"operator return true",
									"left operand is false":"operator return right operand evaluation result value",
									"left operand is number data type value":{
										"left operand is 0":"operator return right operand",
										"left operand is other than 0":"operator return left operand"
									}
								}
							},
							"notation":"operand || operand"
						},
						"NOT operator":{
							"function":{
								"Boolean data type":{
									"operand is true":"operator return false",
									"operand is false":"operator return true"
								},
								"Number data type":{
									"operand is 0":"operator return true",
									"operand is not 0":"operator return false"
								},
								"String data type":{
									"operand is empty":"operator return true",
									"operand is not empty":"operator return false"
								}
							},
							"use":{
								"convert to boolean data type":{
									"how to use":"!! operand",
									"alter notation":{
										"example":"const str = jj , !!str ⇒　str.length > 0"
									}
								}
							},
							"notation":"!operand"
						}
					}
				},
				"Grouping operator":{
					"function":"operators expressly evaluate grouping operand first",
					"notation":"(operand)"
				},
				"Commma operator":{
					"function":"operators expressly evaluate operands from left to right"
				}
			}
		},
		"Type conversion":{
			"implicit type conversion":{
				"function":"operator convert operad data type before execute operate",
				"type conversion rules":{
					"any data type to Boolean":{
						"falsy":{
							"conversion rule":"falsy value vonverted to false",
							"value of falsy":"false, undefined, null, 0, NaN, \"\""
						}
					},
					"any data type value other than falsy":"operator convert various data type value dependent on operator"
				}
			},
			"Explicit type conversion":{
				"to Boolean":{
					"Boolean constructor function":{
						"function":{
							"falsy value":"if orgument is falsy value, function return false",
							"not falsy value":"function return true"
						},
						"notation":"Boolean(orgument)"
					}
				},
				"to String":{
					"String constractor function ":{
						"from Primitive data type value":{
							"String data type value":"function return as it is",
							"true, false, null, undefined symbol":"return argument as string",
							"Synbol(exlain)":"return Synbol(exopain) as string"
						},
						"from object data type value":{
							"array":"return elemens => element, element, ・・・・",
							"object":"return [object object]",
							"function(){}":"return function(){}",
							"() => {}":"return () => {}"
						},
						"notation":"String(argument)"
					},
					"to Number":{
						"Number constructor function":{
							"parseInt":{
								"function":"return number as integer",
								"notation":"Number.parceInt(String, base number), base number is 10 or 8 or 2or 16"
							},
							"parseFloat":{
								"function":"return number as floating point number",
								"notation":"Number.parseFloat(String)"
							},
							"argument contain other than number":{
								"contain number":"ignore other than number, and return number",
								"do not contaion number":"return NaN"
							},
							"isNaN":{
								"function":"evaluate argument is Nan or not",
								"notation":"Number.isNaN(argument)"
							},
							"charactaristic of Nan":{
								"operation result":"if NaN is operand, any operator return NaN regardless other operand",
								"NaN is not mach itself":"=== operator evaluate NaN === NaN to false"
							}
						}
					}
				}
			}
		},
		"function and declaration":{
			"function object":{
				"function is a object that put together formulas or input/output":{
					"function has pre status and post status essentially":{},
					"function enable to contain operation target essentially":{}
				}
			},
			"dummy argument":{
				"dummy argument is operation target":{},
				"function":"contain argument value",
				"notation":"(argument, argument, argument, ..)",
				"assingnment argument value to dummy argument":{
					"argument is less than dummy argument":{
						"dummy argument do not have default argument":"remeinder dummy argument value is undefined",
						"dummy argument have default argument":"remeinder dummy argument value is default argument value",
						"default argument":{
							"notation:":"(dummy argument = default argument, dummy argument = default argument)",
							"alternate notation":"function function name(argument) {const arg = argument || default}",
							"important point of alternate notation":"if arugument is empty strign value, argument return default"
						}
					},
					"arguments are more than dummy argument":{
						"function ignore remeinder argument":{}
					},
					"variable arguments":{
						"rest parameters":{
							"notation":"(argument, ...rest parameters) rest parameters is end of arguments",
							"function":"restparameters has array of all remeinder arguments orderd by permutation"
						},
						"spred syntax":{
							"notation":"function(...array)",
							"function":"call operator spread array and store element to dummy arguments"
						},
						"arguments":{
							"arguments is specific variable onlu used in function":{
								"arguments is array-like object, but not Array":{
									"argument contain elements having index, and call by index like array":{
										"arguments do not have array method":{}
									}
								}
							},
							"notation":{
								"function fn() {x = arguments[0]}":{}
							}
						},
						"Destructuring assignment":{
							"object":{},
							"array":{}
						}
					}
				}
			},
			"function expression":{
				"function declaration":{
					"notation":"function function name(dummy argument, dummy argument, ..) {return return value}",
					"call with function name":{
						"notation":"function name(argumen, argument, ...)"
					}
				},
				"function formula":{
					"without function name":{
						"notation":"const variable = function() {}",
						"call function notation":"variable()",
						"function without function name is called annonymus function":{},
						"arrow function":{
							"notation":"const variable = () => {}",
							"elipsis":{
								"const variable = a argument => {}":{
									"elipisis ()":"if dummy argument is one, function do not need ()",
								"const variable = argument => argument * 2;":{
									"elipisis {} and return":"if function has only one formula, function do not need blocks and return, and return evaluation of formula"
								}
							},
							"new operator":"TypeError: instance is not a constructor"
						}
					},
					"with function name":{
							"const variable = function function name() {}":{
								"function name is valid only in the function":{
									"use":"recursive call in function"
								}
							}
						}
					},
					"prototype object and constructor":"anonymas function have prototypeobject containing constructor"
				},
				"function declaration with same function name":{
					"override":"function name is overrided with last function"
				},
				"prototype object and constructor":"function declaration make prototype object containing constructor automatically"
			},
			"call back function":{
				"function":{
					"call back function is argument, and is executed in caller function":{
						"caller function is nemed higher-order function":{},
						"exampele":"const array = [1, 2, 3]; const output = value => console.log(value); array.forEach(output);",
						"alterate notation of exampe":"const array = [1, 2, 3];, array.forEach(value => console.log(value););"
					}
				}
			},
			"method":{
				"method is function that is property value of object":{
					"notaion":"const obj = {method:()=>{}, otherproperty:othervalue}"
				},
				"assingment function to property":{
					"alternate notation":"object.method = () => {};"
				},
				"call method":{
					"notation":"obj.method()"
				},
				"abbreviated notation":"const obj = {methodname(argument) {return argument;}, otherproperty:othervalue}"
			}
		},
		"Statement and Expression":{
			"JavaScript is struvtured with Statements and Expressions":{},
			"Expression":{
				"function":{
					"evaluate and return evaluation value":{
						"expression evaluate statement itself and retrun evaluation value":{},
						" assignment operator can assign evaluation value to variable":{}
					}
				},
				"example":"literal value, set of operand and operator, function"
			},
			"Statement":{
				"step to process is named statement":{
					"one step is one statement":{}
				},
				"notation":"statement; statement end at semicolon",
				"example":{
					"if satement, for stetement":"if and for do not evaluate and do not return evaluation value",
					"expression statement":{
						"simple substance expression":"one step expression is one statement",
						"notation":"expression;"
					},
					"block stetement":{
						"block":{
							"function":"block put together multiple statements",
							"notation":"{} ,statement block statement do not need semicolon"
						},
						"notation":"if statement end at block, statement do not need semicolon"
					}
				}
			}

		},
		"conditional branch":{
			"condition":"condition is premitive recognition as same and different, that is expanded preposition and postposition",
			"if statement":{
				"single condition":{
					"notation":"if (boolean data type value) statement; , statement is usualy used block{}",
					"function":"if boolean data type value is true, if statement process postposition statement",
					"recognition":"that condition is true is preposition, and statement is postposition",
					"else statement":{
						"notation":"if (boolean data type value) {} else statement;, else need that notation that if () {} before else, if elipsis {} and postposition statement of true is used semicolon cleary supplement {}",
						"function":"if beelean data type is false, if statement process postposition else statement",
						"recognition":"that condition is false is preposition, and else statement is postposition"
					}
				},
				"common function":"postposition statement is nothing, if-statement do not process any statemens, not return preposition condition and branch to false",
				"multiple condition":{
					"use":"postposition statement is conditional branch",
					"if condition is false":{
						"else if statement":{
							"notation":"if(boolean) {} else if(boolean data type) statement; , {} is need same as else statement",
							"function":"if boolean data type value of else if is true, if statement process postposition statement",
							"recognition":"else statement is conditional branh",
							"attention point":"if else-statement is true and process statement, if-statement end, so that post else-statement or else-if-statement is not processed"
						}
					},
					"if condition is true":{
						"nested-if statement":{
							"notation":"if(boolean) if(boolean data type) statement;",
							"function":"if nested boolean data type value is true, if-statement process nested postposition statement",
							"recognition":"if statement is conditional branh",
							"attention point":"if statement is false, and postposition statement is nothing, if-statement end, so that do not return to preposition condition"
						}
					}
				}
			},
			"swich statement":{
				"recognition":"that two conditions are same is preposition, and statement is postposition",
				"notation":"switch (condition expression) {case expression: statement; break; case expression statement; break; default: statement; break; , swith statement neet block",
				"function":"switch-statement evaluate condition expression, and evaluate case expression, and evaluate with strict equal operator two evaluation value, if evaluate and return true, process case statement",
				"attention point":"if === oparator return true, switch-statement  do not evaluate next case expression, and process next case statement unconditionaly",
				"break statement":{
					"function":"end switch statement to include break",
					"notation":"break;"
				}
			}
		},
		"loop and iterative processing":{
			"recognition":"do same thing literatively",
			"while statement":{
				"recognition":"preposition condition is true, and process postposition statement iteratively, end that preposition condition is false",
				"alternate recognition":"do if-statement iteratively, end that condition of if-statement is false",
				"function":"while statement evaluate condition, if condition is true, process statement, and next while-statement iteratively, end that condition of if-statement is false",
				"notation":"while (condition expression) {statement;} , if while statement is elipsised {}, supplement {}, but end at ;",
				"attention point":"preposition condition of if-statement is always true, while-statement process if-statement unlimitedly"
			},
			"do-while statement":{
				"recognition":"process preposition statement, and postposition condition is true iteratively, end to postposition condition is false",
				"function":"while statement process statement, and evaluate condition, if condition is true, process next while-statement iteratively, end that condition of if-statement is false",
				"notation":"do {statement;} while (condition expression);",
				"attention point":"preposition condition of if-statement is always true, while-statement process if-statement unlimitedly"
			},
			"for statement":{
				"recognition":"preposition condition is true, and process postposition statement iteratively, end that preposition condition is false",
				"alternate recognition":"do if-statement iteratively, end that condition of if-statement is false or same as while statement",
				"notation":"for (initial expression; condition expression; inclemental expression) {statement;}",
				"function":"for statement evaluate condition, if condition is true, process statement, and process next for statement. next is that process inclemental expression, and evaluate condition expression , if condition is trut, process statement and next for statement iteratively, end that condition of if-statement is false",
				"attention point":"evaluation result of condition expression is always true, for-statement process for-statement unlimitedly"
			},
			"method of Array":{
				"forEach":{
					"function":{
						"forEach method is property value of Array object":"{Array object:{Array:[element, element, ...], forEach:method, ...}}",
						"forEach method assign element to dummy argument of callback-function and process function expression, process each element one by one, from index 0 to last index":{},
						"callback function":"callback function is function expression to be assigned to dymmy argument of function",
						"higher-order function":"higher-order function is function to assign callback function to dummy argument"
					},
					"notation":"const array = [1, 2, 3]; array.forEach(callback dummy argument => {statement;} , {} is need, but statement is one expression, able to elipsis {} without )"	
				},
				"some":{
					"function":{
						"some method is assign element to dummy argument of callback-function and process function expressoin, process each element one by one, from index 0 to last index ,to end that call-back function return true or end of elements":{
							"if call-back function return true":"some method return true and end",
							"if call-back function that its dummy argument assigned last element of array return false":"some method return false and end"
						}
					},
					"notation":"const array = [1,2,3]; array.some(x => {rerutn express})"
				},
				"filter":{
					"function":{
						"forEach method assign element, index, array to dummy argument of callback-function and process function expression, process each element one by one, from index 0 to last index, and return array":{
							"if callback function returned true":"assign element to array to be returned value"
						}
					}
				}			
			},
			"break statement":{
				"function":"end for or while or do-while statement ,to include break",
				"notation":"break;",
				"use":"while (condition){if(if condition){break;}};"
			},
			"continue statement":{
				"function":"end for or while or do-while statement, to include continue, and continue to process next while or do-while statement",
				"notation":"continue",
				"use":"while (condition){if(if condition){continue;}};"
			},
			"for...in statement":{
				"function":{
					"variable in for...in statement":" for...in statement assign object property to variable, and process statement iteratively till end to last property "
				},
				"notation":"for (variable in object) {statement;}",
				"use":"const obj = {a:1, b:2, c:3}; for (x in obj) {console.log(`x:${obj[x]}`);}"
			},
			"for...of statement":{
				"function":"for...of statement assign property value to variable and process statement iteratively till end to last property",
				"notation":"for (variable of iterable object){statement;}",
				"iterable object":{
					"definition":"iterable object is object to have iterable method",
					"iterable method":"iterable method is process to prosess iteratively",
					"example":"array abject, string object"
				}
			}
		},
		"object":{
			"recognition":{
				"object":"target to recognize as it is, or the object",
				"propertie":"element object to have, and be able to name element"
			},
			"function":{
				"object is set of properties":{
					"properteie":{
						"propertie is pair of key and value":{
							"recognition":{
								"key":"element name",
								"value":"element as it is"
							}
						}
					}
				}
			},
			"notation":{
				"object literal":"{}",
				"object":{
					"{key : value}":{
						"left is key, right is value, and tyey are separated by colon":{},
						"propertie name is abele to use as variable":"quote of propertie name is able to elipsis",
						"propertie name is not able to use as variable":"quote of propertie name is not able to elipsis",
						"value is variable":"value referene to valiable and propertie get valiable value"
					},
					"{variable}":{
						"value is variable and propertie name is variable name" : "propertie value is able to elipsis"
					},
					"{key : value, key : value}":{
						"object has multiple properties":"object express properties side by side separated by comma"
					}
				},
				"Access to properties":{
					"obj.key (object name.propertie nam)":{
						"propertie name is abele to use as variable":"object reference propertie with dot notation",
						"propertie name is not abele to use as variable like 1,2,3,-":"object is not able to reference propertie with dot notation"
					},
					"obj[key] (object name[propertie name])":{
						"propertie name is not abele to use as variable like 1,2,3,-":"object reference propertie with bracket notation",
						"propertie name is abele to use as variable":"object reference propertie with bracket notation"
					},
					"obj[variable]":{
						"variable value is String data type or Synmbol":{
							"variable to reference paropatie name":"variable reference propertie name and, object reference propertie with bracket notation"
						},
						"variable value is not String data type or not Synbol":"variable convert variable value data type to String data type and  reference propertie name and, object reference propertie with bracket notation"
					}
				},
				"Add propertie to object":{
					"obj.key = value":{
						"propertie name added is abele to use as variable":"object reference propertie with dot notation",
						"propertie name added is not abele to use as variable like 1,2,3,-":"object is not able to reference propertie with dot notation"
					},
					"obj[key] = value":{
						"propertie name is not abele to use as variable like 1,2,3,-":"object reference propertie with bracket notation",
						"propertie name is abele to use as variable":"object reference propertie with bracket notation"
					},
					"obj[variable] = value":{
						"variable to reference paropatie name":"variable reference propertie name and, object reference propertie with bracket notation"
					}
				},
				"Delete propertie":{
					"delete obj.key":{
						"delete delete propertie designation by object name propertie name and return true":{
							"alternation notation":"delete obj[key]"
						}
					}
				}
			},
			"Destructuring assignment":{
				"object = {key:value, key:value}; const {valiable, valiable} = object":{
					"use":{
						"elipsis to notate redundancy":{
							"redundancy notation":"const variavle = object.key, const variable = obj.key"
						}
					}
				}
			},
			"Const variable and assign object data type value":{
				"const ristrict that variable reassign, and do not restrict mutation of value":{}
			},
			"Check existence of propertie":{
				"obj.key !== undefined":{
					"evaluate value of non existence propertie":"object return undefined",
					"evaluate value of existence propertie":"object return propertie value",
					"concern":"if propertie is existe and propertie value is undefined, object return undefined"
				},
				"in operator":{
					"function":{
						"propertie is existe":"in operator return true",
						"propertie is not existe":"in operator return false",
						"inheritance source":{
							"propertie is existe in inheritance source":"Serch inheritance source property and return true",
							"propertie is not existe in inheritance source":"Serch inheritance source property and return false"
						}
					},
					"notation":"key in obj , (propertie name in object name)"
				},
				"hasOwnProperty method":{
					"function":{
						"propertie is existe":"object return true",
						"propertie is not existe":"object return false",
						"inheritance source":"do not serch inheritance source"
					},
					"notation":"obj.hasOwnProperty(key)"
				}
			},
			"toString method":{
				"function":{
					"object":"object convert object data type to string data type itself, and return [object Object]"
				},
				"notation":"obj.toString()",
				"String constractor function ":{
					"function":"String constactor function call toString method of object in function",
					"notation":"String(obj)"
				}
			},
			"Static method of Object to be built in object":{
				"enumeration":{
					"keys method":{
						"function":"return property name array",
						"notation":"Object.keys(obj)"
					},
					"values method":{
						"function":"return property value array",
						"notation":"Object.values(obj)"
					},
					"entries method":{
						"function":"returnd pair of property name and value array",
						"notation":"Object.entries(obj)"
					}
				},
				"merge and copy":{
					"merge":{
						"assign method":{
							"function":"assign method merge source object properties to target object and return terget",
							"notation":"Object.assign(target, source, soure, ...source)",
							"target is empty object":"Object.assign({}, objectA, objectB)",
							"target is consted object":{
								"notation":"const objectC = {key1:val1}, Object.assign(objectC, objectA, oBjectB)",
								"same propaerty is not exist":"merge and return target",
								"same propaerty is exit":"merge and reassign last sorce value to property to have same property name and return target"
							}
						},
						"spread syntax":{
							"function":"spred syntax make merged object in object literal",
							"notation":"{...ObjectA, ...ObjectB}"
						}
					},
					"copy":{
						"Object do not have copy method, and Javascript do not prepare copy syntax":{
							"assign method":{
								"sharrow copy":{
									"function":"copy 1st layer",
									"notation":"const shallowClone = (obj) => {return Object.assign({}, obj)}"
								},
								"deep copy":{
									"function":"copy all layer",
									"use sharrow copy":{
										"notation":"const deepClone = (obj) => {const newObj = shallowClone(obj); Object.keys(newObj).filter(k => typeof newObj[k] === object).forEach(k => newObj[k] = deepClone(newObj[k])); return newObj;}"
									}
								}
							}
						}
					}
				}
			}
		},
		"Prototype Object":{
			"Structure of Object":{
				"Object":{
					"prototype":{
						"hasOwnProperty":{},
						"toString":{},
						"valueOf":{},
						"etc":{}
					}
				}
			},
			"inheritance of prototype object":{
				"object literal":"object literal create object to inherit prototype object",
				"create method":{
					"assign Object.prototype":{
						"object method":"created object has prototype object",
						"notation":"Object.create(Object.prototype)"
					},
					"assign null":{
						"object method":"created object do not have any inheritance properties",
						"notation":"Object.create(null)",
						"use":"Object.create(null) used for Map before ES2015"
					}
				}
			},
			"object has same propatie name in prototype object and instance object":"object use instance propatie prioritize",
			"Array prototype":{
				"Object and Array":"Array has Array prototype object and Array prototype inherit Object prototype",
				"array literal":"array literal create array to inherit array prototype object and object prptotype object"
			}
		},
		"Array":{
			"recognition":"objects",
			"Create array and access":{
				"Create array":{
					"array literal":{
						"function":"create array",
						"notation":"[element, element, element]"
					},
					"element":{
						"recognition":"properties of array",
						"function":"element store any value",
						"element value":"null, undefined, Synbol, String, Number, Object, Array, etc...",
						"variable":"variable is able to be element but evaluate before to finish statement",
						"no element":{
							"undefined":"if element do not be exist, return undefined",
							"notation":"[, , , , element, ,]"
						}
					},
					"create two-dementional array":{
						"notation":"[[], [], []]"
					}
				},
				"Access to array element":{
					"index":{
						"recognition":"name of element",
						"function":"specify element",
						"data type":"index is String data type",
						"notation":"array[index]"
					},
					"access tp two-dementional array":{
						"index":{
							"function":"evaluate element one by one from left to right",
							"notation":"array[][]"
						}
					}
				},
				"length method":{
					"function":"length method return length of array",
					"notation":"array.length",
					"use":"access to  element to have last index",
					"example":"array[array.length - 1]"
				}
			},
			"Discriminate Object or Array":{
				"Array prototype":{
					"isArray method":{
						"function":"discriminate array from object",
						"notation":"Array.isArray(obj)"
					}
				}
			},
			"Destructuring assignment":{
				"function":"assign left array element value to ritht array variable as element",
				"notation":"const array[variable, variable, ...] = array",
				"point of evaluate element":"evaluate variable after executetion destructuring assignment"
			},
			"Find element from Array":{
				"Get index":{
					"indexOf method":{
						"function":"method operate strict ecual operator with argument and each element, if evaluate true retrun Number Data type index of element, else return Number data type -1",
						"notation":"array.indexOf(value)",
						"Other than object":"if array incrude the argument value, ==== oparator evaluate true, and return index",
						"Object":{
							"same object":{
								"function":"==== oparator evaluate true, and return index",
								"notation":"obj1 = {}, array = [obj1], array.indexOf(obj1)"
							},
							"other object to have same properties":{
								"function":"==== oparator evaluate false, and return -1",
								"notation":"obj1 = {}, array = [obj1], array.indexOf({})",
								"alternate notation":{
									"findIndex method":{
										"function":"method assign each element to callback function one by one , if callback function return true, method return Number data type index, else return -1",
										"notation":"array.findIndex((obj) => {return express})"
									}
								}
							}
						}
					}
				},
				"Get element":{
					"find method":{
						"function":"method assign each element to callback function one by one , if callback function return true, method return element, else return -1",
						"notation":"array.find(call backfunction)",
						"example":"variable = array.find((obj) => {return express}) console.log(variable)"
					},
					"findIndex method":{
						"function":"method assign each element to callback function one by one , if callback function return true, method return Number data type index, else return -1",
						"notation":"array.findIndex(call backfunction)",
						"example":"variable = array.findIndex((obj) => {return express}); console.log(array[variable])"
					},
					"indexOf method":{
						"example":"variable = array.indexOf(value); console.log(array.[variable])"
					},
					"Get elements in Specified range index":{
						"slice method":{
							"function":"return elements from 1st argument to 2nd argument, if do not assign end index to 2nd dummy argument",
							"notation":"array.slice(start index, end index)"
						}
					}
				},
				"Get Boolean valuem that array incrud a element or not":{
					"indexOf method":{
						"example":"variable = array.indexOf(value); if(value !== -1) retult = true, else result = false"
					},
					"includes method":{
						"function":"method operate strict ecual operator with argument and each element, if evaluate true retrun true, else return false",
						"notation":"array.includes(value)"
					}
				},
				"Push and Delete element":{
					"Push":{
						"Push element to end":{
							"push method":{
								"function":"push value to new element to be end of array",
								"notation":"array.push(value)",
								"return value":"length of array to be status after method operate"
							}
						},
						"Push element to top":{
							"unshift method":{
								"function":"push value to new element to be top of array",
								"notation":"array.unshift(value)",
								"return value":"length of array to be status after method operate"
							}
						}
					},
					"Delete":{
						"Delete element from end":{
							"pop method":{
								"function":"pop element from end",
								"notation":"array.push()",
								"return value":"deleted element value"
							}
						},
						"Delete element from top":{
							"shift method":{
								"function":"pop element from top",
								"notation":"array.shift()",
								"return value":"deleted element value"
							}
						}
					}
				},
				"Merge arrays":{
					"concat method":{
						"function":"array merge an other array",
						"noatation":"array.concat(value)",
						"value is array":{
							"function":"method add argument array elementd to end of array to have method"
						},
						"value is other than array":"method add argument value to end of array to have method"
					}
				},
				"Spred array":{
					"Spred syntax":{
						"function":"return spred elements",
						"notation":"...array",
						"spreded elements":"element, element",
						"use":"defin array element, console.log()"
					}
				},
				"Flattenning":{
					"Flatten multidimensional array":{
						"flat method":{
							"function":"flatten multidimensional array to flat array, till specified dimention, and return flat array",
							"notation":"array.flat(dimention)",
							"example":{
								"flatten array by one dimentional":{
									"notation":"array.flat(1)",
									"alternate notaion":"array.flat()",
									"result":"[[[A], B], C] ⇒ [[A], B, C]"
								},
								"flatten array by all dimentional":{
									"notation":"array.flat(Infinity)",
									"result":"[[[A], B], C] ⇒ [A, B, C]"
								}
							}
						}
					}
				},
				"Delete specified element":{
					"splice method":{
						"function":"delete specified element and stuff element or add element",
						"notation":"array.splice(index, element count, added elements)",
						"example":{
							"delete and stuff element":{
								"notation":"array.splice(0, 2)"
							},
							"delete and add elements":{
								"notation":"const array = [sister, brother]; array.splice(0, 1, papa, mama)",
								"function":"delete element and add elements from delete element index",
								"return element":"return [brother]"
							}							
						},
						"return value":"return array contain only delete elements"
					},
					"length property":{
						"handling":"count elements of array is length property",
						"delete element":{
							"notation":"array.length = count element",
							"function":"cut off elements from specified index to be next of count elements"
						}
					}
				},
				"Assign empty element":{
					"reassign":{
						"example":"let array = [1, 2, 3]; array = []"
					}
				},
				"Destructive method and Non-destructice method":{
					"Destructive method":{
						"pop method":{
							"return value":"added value"
						},
						"push method":{
							"return value":"value length after change"
						},
						"splice method":{
							"return value":"array to contain delete elements"
						},
						"reverse method":{
							"return value":"array that element order is reversed"
						},
						"other method":"shift, sort, unshift, copyWthin, fill"
					},
					"Non-destructive method":"concat, slice"
				},
				"Iterate method":{
					"forEach method":{
						"function":{
							"argument":"callback function",
							"Process":{
								"assign dummy argument of callback function":"assin each element to dummy argument of callback functionone, one by one"
							}
						},
						"notation":"array.forEach((dummy argument) => {statement;})"	
					},
					"Map method":{
						"function":{
							"argument":"callback function",
							"return value":"new array",
							"Process":{
								"assign dummy argument of callback function":{
									"1st dummy argument":"assign each element to dummy argument of callback functionone, one by one",
									"2nd dummy argument":"assign index",
									"3rd dummy argument":"assign array"
								},
								"callback function return value":{
									"return value":"add return value to array",
									"do not return":"do not add to array"
								}
							}
						},
						"notation":"array.map((currentValue, index, array) => {statement;})"	
					},
					"Filter method":{
						"function":{
							"argument":{
								"assign dummy arument of map method":"callback function",
								"return value":"new array",
								"callback function return value":{
									"return true":"add curentValue to array",
									"return false":"do not add to array"
								}
							},
							"Process":{
								"assign dummy argument of callback function":{
									"1st dummy argument":"assign each element to dummy argument of callback functionone, one by one",
									"2nd dummy argument":"assign index",
									"3rd dummy argument":"assign array"
								}
							}
						},
						"notation":"array.map((currentValue, index, array) => {statement;})"	
					},
					"reduce method":{
						"function":{
							"argument":{
								"1st":"callback function",
								"2nd":"initial acumulator"
							},
							"returned value":"number data type value that call back function return in last Iterate",
							"Process":{
								"assign dummy argument of callback function":{
									"1st dummy argument":"assign initial acumulater, and next assign returned value of callback function",
									"2st dummy argument":"assign each element to dummy argument of callback functionone, one by one",
									"3nd dummy argument":"assign index",
									"4rd dummy argument":"assign array"
								}
							}
						},
						"notation":"array.forEach((dummy argument) => {statement;})"	
					}
				},
				"Method chain and Higher-order function":{
					"Method cain":{
						"function":"evaluate method from left to right",
						"notation":"object.method.method.method",
						"use higher-order function in method chain":{
							"example":"const filteArray = array.filter(obj => obj.year<= 2000).map(obj => obj.name)"
						}
					}
				}
			}
		},
		"String":{
			"recognition":"express varval",
			"create string data type value":{
				"string literal":{
					"notation":{
						"double quote":"put string in double quote",
						"single quote":"put string in single quote",
						"back quote":{
							"simple use":"put string in single quote",
							"template literal":{
								"multiple line":"be able to express linefeed by enter",
								"place holder":{
									"notation":"${express}",
									"function":"evaluate express before literal return string"
								}
							}						
						}
					}
				}
			},
			"escape sequence":{
				"function":"express character to be usual specialy interpreted",
				"notation":" start character with /",
				"reference":"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String"
			},
			"Bind strings":{
				"use + operator":{
					"notation":"String + String"
				},
				"use place holder":{
					"notation":"`String${express}String`"
				}
			},
			"Access to a part of String":{
				"use index":{
					"function":"concert to object and String Object return element",
					"notation":"string[index]",
					"undefined":"if element is not exist, return undefined"
				}
			},
			"Bind and Split String":{
				"split method":{
					"function":"method split string by derimiter to character and return array to contain character",
					"notation":"str.split(delimiter)",
					"return value":"array",
					"regular expression":" split method is able to assign regex to argument"
				},
				"join method":{
					"function":"method join string elements of array with derimiter, and return string",
					"notation":"array.join(delimiter)",
					"return value":"string"
				},
				"replace delimiter":{
					"notation":"str.split(delimiter).join(delimiter)"
				}
			},
			"Length of string":{
				"length property":{
					"value":"conde unit count",
					"notation":"string.length",
					"String object":"string convert string to string object and string object return property value"
				}
			},
			"compair string":{
				"relational operator":{
					"String object":"string is converted to String object",
					"string equal operator (===)":{
						"recognition":"strings is same",
						"function":"compaire each code unit, and length propaerty value"
					},
					"other relational operator (>, <, >=, <=)":{
						"function":"compaire last code unit to be element value"
					}
				}
			},
			"Get part of Stging":{
				"slice method":{
					"function":"slice and return string between arguments",
					"notation":"str.slice(start index, end index)",
					"argument":{
						"start index <= end index":"return string between indexs",
						"do not assign end index":"end index is last index and evaluate",
						"start index is negative and end index is not assigned":{
							"notation":"str.slice(negative number)",
							"function":"start index is counted array element backwads"
						},
						"start index >= end index":"return empty string"
					}
				},
				"substring method":{
					"function":"slice and return string between arguments",
					"notation":"str.substring(start index, end index)",
					"argument":{
						"start index <= end index":"return string between indexs",
						"do not assign end index":"end index is last index and evaluate",
						"start index is negative and end index is not assigned":{
							"notation":"str.substring(negative number)",
							"function":"start index is 0 and ebaluate"
						},
						"start index > end index":"reverse start index and last index"
					}
				},
				"Find String":{
					"indexOf method":{
						"function":"surch string from front and return index of element that is first maching value",
						"notation":"str.indexOf(string)",
						"example":{
							"express":"abcdefg.indexOf(bcd)",
							"return value":"1"
						},
						"return value":{
							"maching value is exist":"return top of index that is mathing elements",
							"maching value is not exist":"return -1"
						}
					}
				},
				"Discriminate to be exist string":{
					"startsWith method":{
						"function":"if argument is exist lead of string, return true, elese return false",
						"notation":"str.startsWith(string)"
					},
					"endsWith method":{
						"function":"if argument is exist end of string, return true, elese return false",
						"notation":"str.endsWith(string)"
					},
					"includes method":{
						"function":"if argument is exist in string, return true, elese return false",
						"notation":"str.includes(string)"
					}
				}
			},
			"Regular expression object":{
				"recognition":"part of string properties",
				"function":"object have matching method, and find strings that matches a pattern",
				"Special character":"exprettion pattern of string with spechal character like + ^ ?",
				"Create Regular esxpression object":{
					"Regular expression literal":{
						"notation":"/pattern/flag",
						"evaluation timing":"whten JavaScript load sourcecord",
						"function":"create regular expression object"
					},
					"RegExp Constructor":{
						"notation":"RegExp(pattern string, flag string)",
						"evaluation timing":"whten New syntax call RegExp",
						"function":"create regular expression object"
					}
				},
				"Find string by Regular expression":{
					"Get index":{
						"String#search method":{
							"notation":"str.search(regular expression object)",
							"function":"search matching pattern from string and return index of first maching pattern"
						}
					},
					"Get matching string":{
						"String#match method":{
							"notation":"str.match(regular expression object)",
							"function":{
								"without g flag":{
									"function":"search matching pattern from string and return value",
									"return value":{
										"match":"array whose element value is string that is first matching with pattern, and array has index and input propertys",
										"never match":"null",
										"index property":"lead index of first maching string in searched string",
										"input propaerty":"searched string"
									}
								},
								"with g flag":{
									"function":"search matching pattern from string and return value",
									"return value":{
										"match":"array whose elements are all string that is matching with pattern",
										"never match":"null"
									}
								}
							}
						},
						"RegExp#exec":{
							"notation":"RegExp.match(str)",
							"function":{
								"without g flag":{
									"function":"search matching pattern from string and return value",
									"return value":{
										"match":"array whose element value is string that is first matching with pattern",
										"never match":"null",
										"index property":"lead index of first maching string in searched string",
										"input propaerty":"searched string"
									}
								},
								"with g flag":{
									"function":"search matching pattern from string and return value, and next index of last index assign to lastindex property of RegExp object",
									"return value":{
										"match":"array whose element value is string that is first matching with pattern",
										"never match":"null",
										"index property":"lead index of first maching string in searched string",
										"input propaerty":"searched string"
									},
									"lastindex property":"RegExp object have lastindex property and exec method start to search from lastindex property"
								}
							}
						},
						"Get part of maching string":{
							"Capruring of RegExp object":{
								"function":"caputure matching pattern in whole matching pattern",
								"notation":"/part of pattern (part of pattern)/",
								"String#match method":{
									"return value":"[array to contain matching string, array to contain matching string with capture in whole maching string]"
								},
								"RegExp#exec method":{
									"return value":"[array to contain matching string, array to contain matching string with capture in whole maching string]"
								}
							}
						}
					},
					"Get Boolean value":{
						"position of pattern in string":{
							"notation":{
								"lead":"^pattern",
								"end":"pattern$"
							}
						},
						"RegExp#test method":{
							"notation":"RegExp.test(str)",
							"function":"if matchin pattern is exist in string, return true, else return false"
						}
					},
					"Replace and Delete of String":{
						"replace method":{
							"function":"method search mattching pattern in string and return string repalaced by replace string",
							"notation":{
								"with string":{
									"notation":"str.replace(maching string, replace string)",
									"return timing":"first match string and replace or do not match"
								},
								"with RegExp":{
									"notation":"str.replace(RegExp, replace string)",
									"RegExp":{
										"without g flag":{
											"return timing":"first match string and replace or do not match"
										},
										"with g flag":{
											"return timing":"search till the end of strig"
										}
									}
								},
								"with callback function":{
									"notation":"str.replace(maching string or RegExp, (all, ...capture) => {return replace string})",
									"callback function argument":{
										"all":"assign whole matching string",
										"capture":"assign captured matching string"
									}
								}
							},
							"delete part of string":{
								"notation":{
									"with string":"str.replace(maching string, empty string)",
									"with RegExp":"str.replace(RegExp, empty string)"
								}
							}
						}
					}
				}
			},
			"Tagged Template function":{
				"function":"call function and assign strings and evaluated values of replace holders",
				"notation":"function`template`",
				"argument":{
					"strings":"tepmpate assign array that elements are each string devided by place holder to 1st dummy argument of function",
					"place holder":"tepmpate assign array that elements are each evaluated palace holder values to 2nd dummy argument of function"
				}
			}
		},
		"String and Unicode":{
			"Code Point":{
				"definition":"character id in Unicode",
				"String#codePointAt method":{
					"function":"convert character that is position specified by index, to codepoint and return",
					"notation":"str.codePointAt(index)"
				},
				"String.fromCodePoint method":{
					"function":"convert codepoint that is argument, to character and return",
					"notation":"String.fromCodePoint(codepoint)"
				}
			},
			"Code Unit":{
				"definition":"Code unit encode Code Point as 16bit Units",
				"encoding":{
					"method name":"UTF-16",
					"single unit":"code point and code unit is sama value",
					"double units":"surrogate pair encode code point ",
					"surrogate pair":{
						"function":"high surrogate and low surrogate that are next to each other is interpretated as surrogate pair",
						"range of high surrogete":"D800~DBFF",
						"range of low surrogete":"DC00~DFFF"
					}
				},
				"count code unit":{
					"String#.length property":{
						"notation":"str.length"
					}
				},
				"access to co code unit":{
					"String Object":{
						"notation":"str[index]"
					}
				}
			},
			"Access to Code Point":{
				"Regular Expression Object":{
					"with u flag":{
						"notation":"/pattern/u",
						"function":{
							"Unit of Argument String":"Code Point"
						}
					}
				},
				"Iterable method":{
					"function":{
						"Unit of Argument String":"Code Point"
					},
					"Array.from method":{
						"function":"split string to character and contain it to array return array"
					},
					"for...of statement":{
						"function":"assign element to variable and execute statement, one by one till the end of element iterately"
					}
				}
			}
		},
		"Rapper Object":{
			"Primitive Data Type and Rapper Object":{
				"convert primitive data type to rapper object":{
					"automatically convert":"primitive data type is automatically converted when use rapper object method or property called"
				},
				"Boolean":{
					"Boolean object":{
						"constructor":{
							"name":"Boolean",
							"create object explicitly":"new Boolean(true or false)"
						}
					},
					"lireral":"true or false"
				},
				"Number":{
					"Number object":{
						"constructor":{
							"name":"Number",
							"create object explicitly":"new Number(number)"
						}
					},
					"lireral":"number"
				},
				"String":{
					"String object":{
						"constructor":{
							"name":"String",
							"create object explicitly":"new String(string)"
						}
					},
					"lireral":"string"
				},
				"Synbol":{
					"Synbol object":{
						"constructor":{
							"name":"Synbol",
							"create object explicitly":"new Synbol(string)"
						}
					},
					"lireral":"synbol data type do not have lireral"
				}
			}
		},
		"Function and Scope":{
			"Scope":{
				"definition":"reference range of variable name and function name and object name",
				"Scope Chain":{
					"function":{
						"referenece the nearest variable or function from current scope to global scope":{
							"first":"search variable or function name in current scope",
							"second":"search variable or function name in next outer scope till global scope iterably"
						}
					}
				},
				"Block Scope":{
					"definition":"scope that each block has"
				},
				"Global Scope":{
					"definition":"outermost scope",
					"property":"global scope is made first in Scope implicitly",
					"Global variable":"variable that is defined in global scope",
					"Builtin Object":"Object that is defined automaticaly before execute statements"
				},
				"Function Scope":{
					"definition":"scope that each block has"
				},
				"roll back of variable declaration":{
					"var":{
						"function":"var syntax define variable at lead of function scope or global scope"					
					},
					"let, const":"do not rollback define"
				},
				"roll back of function declaration":{
					"function":"function syntax define function name at lead of function scope or global scope"
				}
			},
			"Static Scope":{
				"funciton":{
					"scope chain":"starting point of outer scope is position of declaine statement, not position of called statement"
				}
			},
			"Memory management":{
				"Gavage correction":{
					"overview":"system to free memory automatically",
					"rerease timing of memory":{
						"reference of variable":{
							"maintain reference":"do not rerease a target data",
							"rerease reference":"rerease a target data"
						}
					}
				}
			},
			"Closure":{
				"function":"maintain variable value in function object",
				"example":"let count = 0; function fn()=> return count++;  variable = fn()",
				"logic that maintain variable value":{
					"static scope":"reference in static scope",
					"maintain reference":"variable maintain reference to the data of object to contain the data"
				},
				"maintain multistatement":{
					"example":"function fn()=>{let count = 0; return innerFn()=>{return count++} }  variable = fn()",
					"logic that maintain variable value":{
						"static scope":"define variable in outer function scope"
					}
				}
			}
		},
		"Function and this":{
			"this value that is not in function":{
				"Execution Context":{
					"Script":{
						"browser":"window object",
						"node,js":"global object"
					},
					"Module":{
						"all environment":"undefined"
					}
				}
			},
			"this value that is in function":{
				"this value is base base object":{
					"base object":{
						"in call function statement":"one left of .method"
					}
				},
				"other than Arrow Function":{
					"Function declaration":{
						"call function as method":"this is base object",
						"call function not as method":"this is undefined"
					},
					"Function expression":{
						"call function as method":"this is base object",
						"call function not as method":"this is undefined"
					},
					"the case that this is undefined":{
						"assingn method to variable":"call function not as method"
					},
					"the case that this is other object":{
						"assign method to other object property":"base object is other object"
					},
					"assign value to this and call function":{
						"Function#call method":{
							"function":"call function and assign value to this and argument",
							"notation":"function.call(this value, argument, ...argument)",
							"not define this":{
								"notation":"function.call(null, argument, ...argument)"
							}
						},
						"Function#apply method":{
							"function":"call function and assign value to this and argument",
							"notation":"function.apply(this value, [argument, ...argument])",
							"not define this":{
								"notation":"function.apply(null, [argument, ...argument])"
							}
						}
					},
					"assign value to this and return new functon":{
						"Function#bind method":{
							"function":"assign value to this and argument and return new function",
							"notation":"function.bind(this value, argument, ...argument)",
							"not define this":{
								"notation":"function.call(null, argument, ...argument)"
							}
						}
					},
					"call back function":{
						"higher-order function":"call back function called by higher-order function as function",
						"this value in call back function":"undefined",
						"how to deal":{
							"use this in directly under method":"assign this value to variable",
							"use function#method":"call, apply, bind method",
							"use other function":"Array#map method have function to assign 2nd argument to this",
							"use Arrow Function":"Arrow Function do not have this and use outer function's this"
						}
					}
				},
				"Arrow Function":{
					"this is not defined":"this is not defined in Arrow Function",
					"Static Scope and Scope Chain":"this search outer function by scope chain",
					"outer function":{
						"call function as method":"this is base object",
						"call function not as method":"this is undefined"
					},
					"call allow function with call,apply,bind method":"ignore this value"
				}
			},
			"reference global object":{
				"notation":"globalThis"
			}
		},
		"Class":{
			"recognition":"a object",
			"Data type":"Function Object, typeof function",
			"define class":{
				"notation":"class class name {statement}"
			},
			"instance":{
				"create instance object":{

				},
				"instance object":{
					"inner property":{
						"use":"instance object call instance method that is searched and finded in properties include inner property automatically",
						"access":{
							"do not be able to access directly":"do not acccess inner property as other property directory",
							"Object.getPrototypeOf":"reference prototype property of instance object"
						},
						"new operator":"TypeError: instance is not a constructor",
						"prototype":{
							"value":"reference to instance object of class"
						}
					}
				}

			},
			"Class object":{
				"Prototype Object of Class":{
					"function to have function object":"function object have prototype property automaticaly",
					"contain":"constructor method, protptype method",
					"property":{
						"do not notate properties as usual object property":{
							"add property":{
								"notate in constructor":"classobject.propertyname = value",
								"notation of class object in itself":{
									"use this":"this.propertyname = value"
								}
							}
						}
					},
					"prototype method":{
						"Prototype object":"define prototype method in prototype object directory",
						"call from class but that is unusual use case":"classname.prototype.method()"
					},
					"ptrototype chain":{
						"object that has inner property prototype, serach method":{
							"find":"execute method",
							"not find":{
								"instance object seach inner property itself":{
									"inner property":{
										"prototype":{
											"value":"reference prototype object of class"
										}
									}
								},
								"find":"instance object execute prototype method that is in prototype object of class"
							}
						},
						"object that has inner property prototype":"instance object, child class object"
					}
				},
				"Constructor method":{
					"function":"new operator create instance object and execute constructor method ",
					"defining position":"Prototype Object",
					"ellipsis of constructor":"create constructor in prototype object automatically",
					"notation":"constructor(argument, ...argument) {statement}",
					"add property to instance object":"this.property name = value",
					"add method to instance object":{
						"use arrow function":"this.property name = (argument, ...argument) => {}",
						"use function declaration":"this.property name = function (argument, ...argument) {}"
					}
				},
				"Prototype method defined in class object":{
					"defining position":{
						"Prototype Object that is Prototype property of Class object that is function object":{
							"Class Object":{
								"prototype":"Prototype Object"
							},
							"Function Object(but not arrow function)":{
								"prototype":"Prototype Object"
							}
						}
					},
					"notation":"functionname(argument, ...argument) {statement}, do not need arrow function or function declaration"
				},
				"method defined in instance object":{
					"defining position":{
						"Instance Object":{
							"method name":"function"
						}
					}

				},
				"Accessor property":{
					"function":"access to inner property by method like usual property",
					"getter":{
						"notation":"get property name() {return inner property value;}"
					},
					"setter":{
						"notation":"set property name(argument) {inner property = argument}"
					},
					"call value from accessor property":"instanse.property name",
					"add value to accessor property":"instanse.property name = value"
				},
				"Static method":{
					"notation":"static functionname(){statement}",
					"function":"define reference to static method in class object directory",
					"Prototype object":"define static method in prototype.constructor property",
					"call":"classname.method()",
					"alternate call":"classname.prototype.constructor.method()"
				},
				"extend":{
					"function":"inherit other class",
					"notation":"class childclass extends parenclass {childclass statement}",
					"prototype chain":{
						"child class have ptototype as inner property in addition to prototype object itself":{
							"inner property":{
								"prototype":"reference to prototype object of pairentclass"
							}
						}
					},
					"super":{
						"elipsis of constructor in child class":"create constructor object and vreate super(argument, ...arguments ) in constructor",
						"call constructor of pairent":{
							"notation":"super(argument, ...arguments)"
						},
						"reference prototype method of pairent class":{
							"notation":"super.prototype method"
						}
					},
					"discrimination to extend":{
						"instanceof operator":{
							"function":"if left instance object is that extended right class, operator return true",
							"notation":"instance object instanceof object"
						}
					},
					"Builtin object":"extend keyword is able to inherit builtin object"
				}
			}
		},
		"Exception handling":{
			"try ...catch syntax":{
				"notation":"try{statements} catch(argument){statements} finally{statements}",
				"try section":{
					"exception targeting":{
						"function":"execute statents, if exception occur, break try section, execute catch section, and or finally section"
					}
				},
				"catch section":{
					"dealing with Exception":{
						"function":"syntax assign error object to catch section argument and execute statements"
					}
				},
				"finally section":"syntax execute finally section statements finally, after try and catch section",
				"ellipsis catch or finally":"be able to elipsis either catch section or finally section"
			},
			"throw statement":{
				"function":"break try section and, assign object to chach section argument and execute catch section statements",
				"notation":"throw object",
				"use":"try{throw new Error(error)} catch(er){console.log(er.message)}}"
			},
			"Error object":{
				"Error constructor":{
					"argument":"string",
					"function":"assign argument value to message property"
				},
				"property":{
					"message":"error message",
					"name":"error object name"
				},
				"stack trace":{
					"function":"contain position of error accured, and position of caller",
					"call":"console.error(Error object)"
				},
				"Builtin Error":{
					"extend":"Builtin Error extends Error object",
					"Reference Error":"reference undefined value",
					"Syntax Error":"Incorect Syntax, so context is not able to read Syntax, before execute",
					"Type Error":"Data type is not except Data type"
				}
			}
		},
		"Asynchronous process":{
			"Recognition":"a process that is differ in time stream from another process",
			"Synchironous processing":{
				"function":"Sequential processing"
			},
			"Asynchronous process":{
				"setTimeout function":{
					"notation":"setTimeout(callback, delay)",
					"function":"call callback function delay milliseconds later"
				}
			},
			"Thread":{
				"default":{
					"execute thread":"mail thread",
					"Synchironous processing":"execute multi process sequentialy",
					"Asynchronous process":"execute multi process concurently"
				},
				"concurent":"execute multi process while swiching in one thread",
				"execute":"execute multi process in multi thread"
			},
			"Asynchronous process Exception in Try ...Catch syntax":{
				"Try ...catch syntax":{
					"Asynchronous function in Try block":{
						"result":"do not catch exeption",
						"reason":"finish to execute Try ... catch syntax, evaluate Asynchronous funcrion"
					}
				}
			},
			"Error first callback rule":{
				"notation":"function(argument, argument, (error, data) => {statements})",
				"function":{
					"reject":"assign null to 1st argument of of callback function, and call callbackfunction",
					"resolve":"assign null to 1st argument of of callback function, and assign data to 2nd argument of callback function and call callbackfunction",
					"example":"const file fs.readFile(path, (error, data)=> if(error){console.error(error)}else{console.log(data)} )"
				}
			},
			"Promise":{
				"create Promise instance":{
					"notation":"new Promise(callback function)",
					"status":"Pending"
				},
				"Promise prototype method":{
					"constructor":{
						"execute callback function":{
							"throw exception":"define expression that call 2nd argumen function in then method, with to assign exception to call back function argument of then method 2nd argument function, then(resolve, reject){resolve(argument of constructor argument function, and catch method)",
							"not throw exeption":{
								"call first argument function primality":"define expression that call 1st argumen function in then method, with to assign argument value to call back function argument of then method 1st argument function, then(resolve, reject){resolve(argument of constructor argument function)}",
								"call secound argument function primality":"define expression that call 2nd argumen function in then method, with to assign argument value to call back function argument of then method 2nd argument function, then(resolve, reject){resolve(argument of constructor argument function, and catch method)}"
							}
						}
					},
					"resolve":{
						"noation":"Promise.resolve(value)",
						"function":"create fullfilled Promise instanse that set value to then method callback function argument"
					},
					"reject":{
						"noation":"Promise.reject(value)",
						"function":"create rejected Promise instanse that set value to then and catch method callback function argument"
					},
					"all":{
						"notation":"Promise.all([promise, promise, promise])",
						"arguments":"Array of promise instaces",
						"function":"create promise instance that in then method define expression 2nd callback function of argumen with callback argument that is array of each instanse argument that is array of callback function argument",
						"return value":{
							"Promise instance":{
								"throw exception or to define called 2nd callbackfunction in then method primallity or define callback in catch method even one of element":{
									"then and catch with throwed exception or reject ":"define expression that call 2nd argumen function in then method, with to assign exception to call back function argument of then method 2nd argument function, then(resolve, reject){resolve(argument of constructor argument function, and catch method)"
								},
								"not throw exeption":{
									"all Promise instance define in then method 1st callbackfunction":{
										"then with array of callbackfunction returned value":"define expression that call 1st argumen function in then method, with to assign array of elements returned value to call back function argument of then method 1st argument function, then(resolve, reject){resolve([returned value, returned value...])}"
									},
									"even one of promise instanse has no callback function":{
										"do not define callback":"do not define then 1st, 2nd callback and catch callback"
									}
								}
							}
						},
						"use with Destructuring assign":"Promise#.all([pro1, pro2, pro3]).then([val1, val2, val3] => {console.log(val1, val2, val3)})"
					},
					"race":{
						"notation":"Promise.race([promise, promise, promise])",
						"arguments":"Array of promise instaces",
						"function":"create promise instance that is a promise instance created at first in array",
						"return value":"Promise instance that is a promise instance whose create time is the shortest in array"
					}		
				},
				"Promise instance method":{
					"then":{
						"Promise#.then(resolve, reject)":{
							"function":"execute callback function",
							"return value":{
								"other than Promise instance":{
									"Promise instance":{
										"throw exception":{
											"then method of instance":"(resolve, reject) => reject(exception)",
											"catch method of instance":"(reject) => reject(exception)"
										},
										"not throw exception":{
											"then method of instance":"(resolve, reject) => resolve(return value of then callback)"
										}
									}
								},
								"Promise instance":"Promise instance"
							}
						},
						"argument is resove only":"Promise#.then(resolve)",
						"argument is reject only":"Promise#.then(undefined, reject)"
					},
					"catch":{
						"Promise#.catch(reject)":{
							"function":"execute callback function",
							"return value":{
								"other than Promise instance":{
									"Promise instance":{
										"then method of instance":"(resolve, reject) => resolve(return value of then callback)"
									}
								},
								"Promise instance":"Promise instance"
							}
						}
					},
					"finally":{
						"Promise#.finally(callback)":{
							"function":"call callback function",
							"return value":{
								"Promise instance":{
									"throw exception":{
										"then method of instance":"(resolve, reject) => reject(exception)",
										"catch method of instance":"(reject) => reject(exception)"
									},
									"not throw exception":{
										"then method of instance":"return call Promise instanse"
									}
								}
							}			
						}
					}
				},
				"Status":{
					"concept":"virtual status to understand promise chain instinctively",
					"then or catch method":"instance ignore pass method and, execute the nearest execute method",
					"Fullfilled":{
						"execute method":{
							"then":"call resolve at once",
							"finally":"call callback function, do not create Promise instance"
						},
						"pass method":{
							"then":"call reject",
							"catch":"call reject"
						},
						"Create FullFilled or Change to Fullfilled":{
							"Create":{
								"instance method":{
									"then method":"Promise#.then(resolve or undefined, reject) ,call resolve or reject and without to throw ecxeption",
									"catch method":"Promise#.catch(reject) ,call resolve and without to throw ecxeption",
									"resolve argument":"returned value of resolve or reject"
								},
								"constructor method":{
									"resolve method":"Promise.resolve(value)",
									"resolve argument":"resolve method argument value"
								}
							}
						},
						"Change from":{
							"Pending ⇒　Fullfilled":"execute then resolve callback function"
						},
						"Change to":"do not change"
					},
					"Rejected":{
						"execute method":{
							"then":"call reject at once",
							"catch":"call reject at once",
							"finally":"call callback function, do not create Promise instance"
						},
						"pass method":{
							"then":"call resolve"
						},
						"Create FullFilled or Change to Fullfilled":{
							"Create":{
								"instance method":{
									"then method":"Promise#.then(resolve or undefined, reject), with to throw exception",
									"reject argument":"throwed exeption"
								},
								"constructor method":{
									"reject method":"Promise.reject(value)",
									"reject argument":"reject method argument value"
								}
							}
						},
						"Change from":{
							"Pending ⇒　Rejected":"execute then reject callback function, or catch reject callback function"
						},
						"Change to":"do not change"
					},
					"Pending":{
						"execute method":{
							"then":"call resolve or reject at once or nothing, if execute nothing pass this method",
							"catch":"call reject at once or nothing, if execute nothing pass this method",
							"finally":"call callback function, do not create Promise instance"
						},
						"Create FullFilled or Change to Fullfilled":{
							"constructor":{
								"Promise":"new Promise(callback)",
								"callback":"call resolve or reject or throw exception or nothing",
								"resolve argument":"any value",
								"reject argument":"any value or exception"
							},
							"Change from":"do not change",
							"Change to":{
								"Pending ⇒　Rejected":"execute then reject callback function, or catch reject callback function",
								"Pending ⇒　Fullfilled":"execute then resolve callback function"
							}
						}
					}
				}
			},
			"Async function":{
				"Create async function":{
					"function declaration":"async function fn1() {}",
					"function expression":"const fn2 = async function() {}",
					"arrow function":"const fn3 = async() => {}",
					"method":"const obj = { async method() {} }"
				},
				"function":{
					"same as function":"async function has functions that have function",
					"return value is promise instance":"return value is wrapped promise instanse, return Promise.resolve(return value) or Promise.reject(expression), if return value is Promise instance, return the Promise instance",
					"await":"async function is able to use await expression in async function limitedly"
				},
				"return value is Promise instance":{
					"Promise instance":{
						"throw exception":{
							"then and catch with throwed exception":"define expression that call 2nd argumen function in then method, with to assign exception to call back function argument of then method 2nd argument function, then(resolve, reject){resolve(argument of constructor argument function, and catch method)"
						},
						"not throw exeption":{
							"return value other than Promise instanse in async functon ":"async function return Promise.resolve(returned vlue), return nothing in async function, asyncfunction return Promise.resolve()",
							"return Promise instanse in async function ":"return the Promise instance"
						}
					}
				},
				"await expression":{
					"recognition":"execute asynchronous process in same time stream",
					"notation":"",
					"function":"wait till to set resolve or reject on then or catch method at first in Promise instance in asyncronous function",
					"return value":{
						"throw exeption":"exception",
						"do not throw exception":{
							"defined resolve primaly":"resolve argument",
							"defined reject primaly":"reject argument",
							"do not be defined any resolve or reject":"exit asyncronous function that is the nearest outer, before return value"
						}
					}
				},
				"async function with loop":{
					"with for loop":"const array = [], async functon fn(for(let i = 0, i < 5, i++)){const val = await async function(); array.push(val)}"
				},
				"async function with Promice prototype method":{
					"with all":"const array = [], const resources = [1,2,3,4,5] const promises = resouces.map((val) => Promise.resolve(val)); async functon fn(const val = await Promise.all(promises)}"
				}
			}
		},
		"JSON":{
			"JSON object":"Builtin object that have method to operate JSON",
			"from JSON to JavaScript":{
				"parse method":{
					"notation":"JSON.parse('string') ,do not use double quote, double quote is used in string so, string do not be treated one string",
					"return value(datatype in json⇒in javascript)":{
						"do not throw exception":{
							"object":"object",
							"array":"array",
							"property":{
								"property name":"string",
								"propaerty value and array element":{
									"string":"string",
									"number":"number",
									"object":"object",
									"array":"array",
									"null":"null",
									"undefined":"error"
								}
							}
						},
						"throw exception":"throw exception and do not return anything"
					},
					"use":"try{JSON.parse(json)} catch(err){console.error(err)}"
				}
			},
			"from JavaScript to JSON":{
				"stringify method":{
					"notation":"JSON.stringify(obj)",
					"return value(datatype in javascript⇒in json)":{
						"do not throw exception":{
							"data type in javescript":"string",
							"object":"object",
							"array":"array",
							"string":"string",
							"property":{
								"propaerty value and array element":{
									"string":"string",
									"number":"number",
									"object":"object",
									"array":"array",
									"null":"null",
									"RegExp":"{}",
									"Map, Set":"{}",
									"Synbol":"do not create property",
									"function":"do not create property",
									"undefined":"do not create property"	
								},
								"property name":{
									"string":"string",
									"Synbol":"do not create property"
								}
							}			
						},
						"throw exception":"throw exception and do not return anything"
					},
					"use second argument":{
						"function":"reprace property value with return value of callback function",
						"notation":"const replacer = (key, value) => {statementd; return property value}; JSON.stringify(obj, replacer)",
						"if property value is null, ignore the property":"const replacer = (key, value) => {if (value === null) {return undefined;}return value;};console.log(JSON.stringify(obj, replacer));"
					},
					"use third argument":{
						"function":{
							"number":"indent properties by space, space amount is the argument number",
							"string":"indent properties by the string",
							"notation":"console.log(JSON.stringify(obj, null, number or string);",
							"indent by tab":"JSON.stringify(obj, null, backslash t)"
						}
					},
					"toJSON method in object":{
						"function":"stringify return toJSON method return value",
						"notation":"obj = {properties ,toJSON() {return value;}",
						"stringify return value":"toJSON method return value"					
					}
				}
			}
		},
		"ECMAScript module":{
			"Purpose":{
				"Maintenanbility":"Centralized management of common process and single functionalization",
				"name space":"each modules have independence space",
				"Reusability":"reuse frequency processings"
			},
			"Export with name":{
				"export":"export {variable or function name};",
				"export multi variables or functions":"export {var, var, fn};",
				"declain and export":"export function fn() { };",
				"export with alias name":"export { var as alias};"
				
			},
			"Import with name":{
				"import":"import { export variable or function name } from module file name;",
				"import var of fn that export with alias":"import {alias} from module;",
				"import with alias":"import { var as alias } from module;"
			},
			"default export":{
				"export":"export default var;",
				"alternate default export":"export {var as default};",
				"declain and export":"export default function fn() { };, variable is not able to declain in export syntax"
			},
			"default import":{
				"import":"import alias from module;",
				"alternate default import":"import {default as alias} from module",
				"import default with orther export function or variable":"import alias, { fn } from module"
			},
			"reexport":{
				"reexport all module":"export * from module;",
				"reexport all module with alias":"export * as myNameSpace from module;",
				"reexport selected function":"export { foo, bar } from module;",
				"reexport selected function with alias":"export { foo as myModuleFoo, bar as myModuleBar } from modeule;",
				"reexport default export as default":"export { default } from module;",
				"reexport default export with name":"export { default as myModuleDefault } from module;",
				"reexport selected function as default":"export { foo as default } from module;"
			},
			"import all functions or variables":{
				"import all":"import * as myModule from module"
			},
			"import module that operate builtin object or global variable":{
				"window.foo = foo;":"import ./side-effects.js;"
			},
			"execute module":{
				"html":"<script type=module src=./my-module.js></script>"
			}
		}
	}
}}