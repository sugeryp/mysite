{"JavaScript":{
	"environment dependence":{},
	"common":{
		"ECMASrript":{
			"distinguish between upper and lowercase letters":{},
			"habe reserved word":{},
			"separate sentence by semicoron":{},
			"strict mode":{},
			"execute context":{
                "Script":{},
				"Module":{}
			},
			"comment":{
				"line comment":{},
				"multiple line comment":{},
				"HTML-like comment":{
					"use":{
						"backward compatibility":{}
					}
				}
			},
			"variables and declarations":{
				"const":{
					"resubstitution":{
						"enable":"false"
					},
					"initial value":{
						"required":"true"
					},
					"same name valiables":{
						"enable":"false"
					}
				},
				"let":{
					"resubstitution":{
						"enable":"true"
					},
					"initial value":{
						"required":"false",
						"undefined initial value":"undefined"
					},
					"same name valiables":{
						"enable":"false"
					}
				},
				"var":{
					"resubstitution":{
						"enable":"true"
					},
					"initial value":{
						"required":"false",
						"undefined initial value":"undefined"
					},
					"same name valiables":{
						"enable":"true",
						"problem":{
							"replace value":{},
							"hoisting":{}
						}
					}
				}				
			},
			"value evaluation and display":{
				"evaluation result":{
					"display":{
						"console display":{
							"evaluation operand":{},
							"error":{
								"SyntaxError":{
									"type":"SyntaxError",
									"discription":{},
									"filename:linenumber:columnumber":{}
								},
								"RunTimeError":{
									"ReferenceError":{
										"type":"ReferenceError",
										"what is not defind":{},
										"filename:linenumber:columnumber":{}
									}
								},
								"TypeError":{}
							}
						}
					}
				}
			},
			"data type and literal":{
				"data type":{
					"primitive":{
						"mutability":"immutable",
						"Boolean data type":"true or false",
						"Number data type":{
							"real number":{
								"integer":["decimal number", "binary number", "octal number", "hexadecimal number"]
							},
							"decimal":{}
						},
						"String data type":{
							"expression":"string",
							"line feed expression":{
									"line feed escape character":"\n"
							},
							"template":{
								"expression":"string",
								"defind variable notation":"${str}",
								"line feed notation":"enter(line feed code)"
							}
						},
						"undefind data type":"value id not defind",
						"null data type":"value is not exist expicitly",
						"Symbol data type":{
							"notation":"variable = Symbol()",
							"notation synbol's explain":"Synbol(explain)"
						}
					},
					"object data type":{
						"non rimitive data":{
							"object":{
								"notation":"key:value",
								"key named in object":"propaty",
								"data type of key":["string", "synbol"],
								"data type of value":"any defined data type is ok",
								"reference value":{
									"dot notation":{
										"notation":"object identifier.propatie identifier",
										"ristrict to use":"propaty required to be identifier"
									},
									"brachet notation":{
										"notation":"object identifire[propatie name]"
									}
								},
								"wrapper object":{
									"string wrapper object":{},
									"number wrapper object":{},
									"boolean wrapper object":{}
								}
							},
							"array":{
								"order of value":{
									"index number of order":"[index0, index1, index2, ...]"
								},
								"reference value":{
									"notation":"array identifire[index number]"
								}
							},
							"function":{},
							"regurar expression":{},
							"etc...":{}
						}
					}
				},
				"data type cheching operator":"typeof",
				"literal":{
					"wahat is the literal":"meta infomation for define data type",
					"notation of literal":{
						"String literal":["\"\"", "single quote"],
						"Number literal":{
							"integer":{
								"decimal number":"integer without decoration",
								"binary number":"0b",
								"octal number":{
									"0o":{
										"strict mode":"enable"
									},
									"0":{
										"strict mode":"disable"
									}
								},
								"hexadecimal number":"0x"
							}
						},
						"Boolean literal":["true", "false"],
						"null literal":"null",
						"object literal":"{}",
						"array literal":"[]",
						"regular expression literal":"\/\/",
						"template literal":"back quote"
					}
				}

			},
			"operator":{
				"binary operator":{
					"plus operator":{
						"function":{
							"Number data type":"add two operand" 
						},
						"notation":"operand + operand"
					},
					"string concatenation operand":{
						"function":{
							"String data type":"join two operand"
						},
						"notation":"operand + operand"
					},
					"minus operator":{
                        "function":{
                            "Number data type":"take a operand from a operand"
                        },
                        "notation":"operand - operand"
                    },
                    "multiplication operator":{
                        "function":{
                            "Number data type":"a operand multiply a operand"
                        },
                        "notation":"operand * operand"
                    },
                    "division operator":{
                        "function":{
                            "Number data type":"a operand divided by a operand"
                        },
                        "notation":"operand / operand"
                    },
                    "surplus operator":{
                        "function":{
                            "Number data type":"surplus by divided two operand"
                        },
                        "notation":"operand % operand"
                    },
                    "exponentiation operator":{
                        "function":{
                            "Number data type":"a operand to the power of a operand"
                        },
                        "notation":{
                            "use exponentiation operator":"operand ** operand",
                            "use method":"Math.pow(operand, operand)"
                        }
                    }
                },
                "unary operator":{
                    "unary plus operator":{
                        "function":{
                            "Number data type":"convert to same operand",
                            "String data type":{
                                "enable to convert to numerical value":"convert to numerical value",
                                "disable to convert to numerival value":{
                                    "convert to":"NaN",
                                    "original name of NaN":"Not-a-Number",
                                    "evaluation about NaN":{
                                        "formula and result":{
                                            "use comparison operator":"console.log(NAN === NAN)=> false",
                                            "use method":{
                                                "use typeof":"console.log(typeof NaN) => number",
                                                "use Number.isNaN(NaN)":"console.log(Number.isNaN(NaN)) => true"
                                            }
                                        }
                                    },
                                    "usual conversion regime":"use Number constructer function or parseInt function"
                                }
                            }
                        },
                        "notation":"+operand"
                    },
                    "unary minus operator":{
                        "function":{
                            "Number data type":"convert to minus numerical value",
                            "String data type":{
                                "enable to convert to numerical value":"convert to minus numerical value",
                                "disable to convert to numerival value":{
                                    "a value converted to":"NaN"
                                }
                            }
                        },
                        "notation":"-operand"
                    },
                    "increment operator":{
                        "function":{
							"Number data type":"a operand plus 1",
							"String data type":{
                                "enable to convert to numerical value":"a operand convert to numerical value and plus 1",
                                "disable to convert to numerival value":{
                                    "convert to":"NaN"
                                }
                            }
						},
						"notation":{
							"prepositional":"++operand",
							"postpositional":"operand++"
						},
						"evaluation":{
							"prepositional":{
								"1st evaluation":"operand + 1",
								"2nd evaluation":"return evaluation result"
							},
							"postpositional":{
								"1st evaluation":"return ebaluation result",
								"2nd evaluation":"operand + 1"
							}
						}
					},
					"decrement operator":{
                        "function":{
							"Number data type":"a operand minus 1",
							"String data type":{
                                "enable to convert to numerical value":"convert to numerical value and minus 1",
                                "disable to convert to numerival value":{
                                    "convert to":"NaN"
                                }
                            }
						},
						"notation":{
							"prepositional":"--operand",
							"postpositional":"operand--"
						},
						"evaluation":{
							"prepositional":{
								"1st evaluation":"operand - 1",
								"2nd evaluation":"return evaluation result"
							},
							"postpositional":{
								"1st evaluation":"return ebaluation result",
								"2nd evaluation":"operand - 1"
							}
						}
                    }
				},
				"strict equal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are same data type and same value, return true",
						"String data type":"operator compaires two operands and if operands are same data type and same value, return true",
						"Object data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"Operands is Null data type":"return true",
						"Operands is Undefined":"return true",
						"Null and Undefined":"operator return false",
						"defference data type":"operator return false"
					},
					"notation":"operand === operand"
				},
				"strict inequal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are different data type or different value, return true",
						"String data type":"operator compaires two operands and if operands are different data type or different value, return true",
						"Object data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"Operands is Null data type":"return false",
						"Operands is Undefined":"return false",
						"Null and Undefined":"operator return true",
						"defference data type":"operator return true"
					},
					"notation":"operand !== operand"
				},
				"equal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are same value, return true",
						"String data type":"operator compaires two operands and if operands are same value, return true",
						"Object data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands referent same data on memory, return true",
						"defference data type":{
							"Number and String":{
								"enable to convert string to numerical value":"operator convert string value to numerical value and compaires number data type values",
								"disable to convert string to numerival value":"operator return false"
							},
							"Number and Boolean":{
								"boolean data type value is true":"operator convert boolean value to number data type 1 and compaires values",
								"boolean data type value is false":"operator convert boolean value to number data type 0 and compaires values"
							},
							"String and Boolean":{
								"enable to convert string to numerical value":{
									"boolean data type value is true":"operator convert string value to numerical value and convert boolean value to 1 compaires number data type values",
									"boolean data type value is false":"operator convert string value to numerical value and convert boolean value to 0 compaires number data type values"
								},
								"disable to convert string to numerival value":"operator return false"
							},
							"Null and Number":"operator return false",
							"Null and Boolean":"operator return false",
							"Null and String":"operator return false",
							"Undefined and Number":"operator return false",
							"Undefined and Boolean":"operator return false",
							"Undefined and String":"operator return false",
							"Null and Undefined":"operator return true"
						}
					},
					"notation":"operand == operand"
				},
				"inequal conparison operator":{
					"function":{
						"Number data type":"operator compaires two operands and if operands are difference value, return true",
						"String data type":"operator compaires two operands and if operands are difference value, return true",
						"Object data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"Array data type":"operator compaires two operands and if operands not referent same data on memory, return true",
						"defference data type":{
							"Number and String":{
								"enable to convert string to numerical value":"operator convert string value to numerical value and compaires number data type values",
								"disable to convert string to numerival value":"operator return true"
							},
							"Number and Boolean":{
								"boolean data type value is true":"operator convert boolean value to number data type 1 and compaires values",
								"boolean data type value is false":"operator convert boolean value to number data type 0 and compaires values"
							},
							"String and Boolean":{
								"enable to convert string to numerical value":{
									"boolean data type value is true":"operator convert string value to numerical value and convert boolean value to 1 compaires number data type values",
									"boolean data type value is false":"operator convert string value to numerical value and convert boolean value to 0 compaires number data type values"
								},
								"disable to convert string to numerival value":"operator return true"
							},
							"Null and Number":"operator return true",
							"Null and Boolean":"operator return true",
							"Null and String":"operator return true",
							"Undefined and Number":"operator return true",
							"Undefined and Boolean":"operator return true",
							"Undefined and String":"operator return true",
							"Null and Undefined":"operator return false",
							"String and String":"unknown"
						}
					},
					"notation":"operand != operand"
				},
				"greater or lesser operators":{
					"common function":{
						"Number and String":{
							"enable to convert string to numerical value":"operator convert string value to numerical value and compaires number data type values",
							"disable to convert string to numerival value":"operator return false"
						},
						"Number and Boolean":{
							"boolean data type value is true":"operator convert boolean value to number data type 1 and compaires values",
							"boolean data type value is false":"operator convert boolean value to number data type 0 and compaires values"
						},
						"String and Boolean":"operator return false",
						"Null and Number":{
							"number is not 0":"operator return result to compaire a number data type operand and 0",
							"number is 0":"operator return false"
						},
						"Null and Boolean":{
							"boolean data type value is true":"operator convert boolean to 1 and null to 0, then operator compaires numerical values",
							"boolean data type value is false":"operator return false"
						},
						"Null and String":{
							"enable to convert string to numerical value":{
								"number is not 0":"operator convert string value to numerical value and null to 0, then operator compaires number data type values",
								"number is 0":"operator return false"			
							},
							"disable to convert string to numerival value":"operator return false"
						},
						"Undefined and Number":"operator return false",
						"Undefined and Boolean":"operator return false",
						"Undefined and String":"operator return false",
						"Null and Undefined":"operator return false"
					},
					"greater operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is greater than right operand, return true"
						},
						"notation":"operand > operand"
					},
					"greater equal operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is greater than right operand, else if operands is same, return true"
						},
						"notation":"operand >= operand"
					},
					"lesser operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is lesser than right operand, return true"
						},
						"notation":"operand < operand"
					},
					"lesser equal operator":{
						"function":{
							"Number data type":"operator compaires two operands and if left operand is lesser than right operand, else if operands is same, return true"
						},
						"notation":"operand <= operand"
					}
				},
				"bitwise operators":{
					"common function":{
						"Number data type":{
							"round down left edge bit over 32bit":{
								"mantissa of operand is or less than 32bit":"operator convert operand",
								"mantissa of operand is more than 32bit":"operator round down left edge bit over 32bit"
							},
							"conversion":{			
								"positive number":"operator convert double precision floating point number operand to Signed 32-bit integer",
								"negative number":"operator convert absolute value of double precision floating point number operand to Signed 32-bit integer then, convert twos complement of 32bit integer type operand",
								"zero":"operator convert double precision floating point number filled 0"
							},
							"return value":{
								"do not flip a left edge bit by bitwise operation after 32bit conversion":"operator return decimal value of Number data type converted from 32 bits interpreted binary number",
								"flip a left edge bit to 1 from 0 by bitwise operation after 32bit conversion":"operator return minus decimal value of Number data type that converted from twos complement of 32 bits interpreted binary number"
							},
							"value range":{
								"in -2147483648 ~ 2147483647, -0b10000000000000000000000000000000 ~ 0b01111111111111111111111111111111":"positive or negative",
								"in 2147483648 ~ 4294967295, or 0b10000000000000000000000000000000 ~ 0b11111111111111111111111111111111":"absolutry positive number",
								"in -4294967295 ~ -2147483649 or -0b11111111111111111111111111111111 ~ -0b10000000000000000000000000000001":"absolutry positive number"
							}
						}
					},
					"Bitwise AND operator":{
						"function":{
							"Number data type":{
								"two operands are 1":"operator return 1",
								"two operands are not 1":"operator return 0"
							}
						},
						"use":{
							"bitwise mask with 0":{
								"operate operand with 0":"operator return 0",
								"operate operand with 1":"operator return operand as it is"
							}
						},
						"notation":"operand & operand"
					},
					"Bitwise OR operator":{
						"function":{
							"Number data type":{
								"two operands are 0":"operator return 0",
								"two operands are not 0":"operator return 1"
							}
						},
						"use":{
							"bitwise mask with 1":{
								"operato operand with 0":"operator return operand as it is",
								"operate operand with 1":"operator return 1"
							},
							"Additive color mixture":{}
						},
						"notation":"operand | operand"
					},
					"Bitwise XOR operator":{
						"function":{
							"Number data type":{
								"two operands are same":"operator return 1",
								"two operands are different":"operator return 0"
							}
						},
						"use":{
							"bit flip":{
								"operato operand with 0":"operator return flipped operand",
								"operate operand with 1":"operator return operand as it is"
							},
							"Additive color mixture":{}
						},
						"notation":"operand ^ operand"
					},
					"Bit nagation operator":{
						"function":{
							"Number data type":"operator return flipped operand"
						},
						"use":{
							"bit flip":{
								"operato operand with 0":"operator return flipped operand",
								"operate operand with 1":"operator return operand as it is"
							},
							"convert -1 to 0":{
								"String.indexOf() in if statement":{
									"why use bit nagation operator":"if can not find string, indexOf method return -1, in if statement, 0 treat as false and other than 0 true so notate concisely ",
									"notation":"if(~str.indexOf(?)) { }",
									"alter notation 1":"if(str.indexOf(?) !== -1) { }",
									"alter notation 2":"if(str.includes(?)) { }  //includes method retern false if can not find string so do not need ~"
								}
							}
						},
						"notation":"~operator"
					},
					"Left shift operator":{
						"function":"operator shift operand by argument bit toward left and round down flow bit at left, and add 0 at right",
						"returned value":"if right edge bit is 1, return minus decimal number converted from twos comprement of 32bit integer value",
						"notation":"operand << bit"
					},
					"Right shift operator":{
						"function":"operator shift operand by argument bit toward right and round down flow bit at right, and add bit value that is same as right edge bit value",
						"returned value":"if right edge bit is 1, return minus decimal number converted from twos comprement of 32bit integer value",
						"notation":"operand >> bit"
					},
					"Zero-fill right shift operator":{
						"function":"operator shift operand by argument bit toward right and round down flow bit at right, and add 0 bit",
						"notation":"operand >>> bit"
					},
					"Assignment operator":{
						"function":"operator assign value to variable",
						"notation":"variable = value",
						"use with binary operator":{
							"function":"operator assingn a result value operated operand by binary operator to variable",
							"notation":"binary operator =",
							"example notation":"+=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, ^=,|="
						},
						"Destructuring assignment":{
							"Array":{
								"function":"operator assingn right operand array element value to left operand array element to have correspond index",
								"notation":"array operand = array operand"
							},
							"Object":{
								"function":"operator assingn right operand object element value to left operand array element to have correspond propaty",
								"notation":"object operand = object operand"
							}
						},
						"Ternary operator":{
							"function":{
								"Ecaluation result of conditional is true":"operator return evaluation result of left formula",
								"Ecaluation result of conditional is false":"operator return evaluation result of right formula"
							},
							"notation":"variable = conditional formula operand ? left formula operand : right formula operand",
							"use":{
								"change Initial value of variable by condition":{
									"alter notation":{
										"if statement":{
											"notation":"let variable; if(conditional formula) {variable = left formula}, else {variable = right formula}"
										}
									}
								}
							}
						}
					},
					"Boolean operator":{
						"AND operator":{
							"function":{
								"operands are true":"operator return true",
								"operands are not true":{
									"left operand is false":"operator return false, operator do not evaluate right operand",
									"left operand is true":{
										"right operand is false":"operator return false",
										"right operand is number":"operand return left operand number"
									},
									"left operand is number data type 0":"operand retun 0",
									"left operand is number data type other than 0":"left operand return true, and operator operate"
								}
							},
							"notation":"operand && operand"
						},
						"OR operator":{
							"function":{
								"operands are false":"operator return false",
								"operands are not false":{
									"left operand is true":"operator return true",
									"left operand is false":"operator return right operand evaluation result value",
									"left operand is number data type value":{
										"left operand is 0":"operator return right operand",
										"left operand is other than 0":"operator return left operand"
									}
								}
							},
							"notation":"operand || operand"
						},
						"NOT operator":{
							"function":{
								"Boolean data type":{
									"operand is true":"operator return false",
									"operand is false":"operator return true"
								},
								"Number data type":{
									"operand is 0":"operator return true",
									"operand is not 0":"operator return false"
								},
								"String data type":{
									"operand is empty":"operator return true",
									"operand is not empty":"operator return false"
								}
							},
							"use":{
								"convert to boolean data type":{
									"how to use":"!! operand",
									"alter notation":{
										"example":"const str = jj , !!str ⇒　str.length > 0"
									}
								}
							},
							"notation":"!operand"
						}
					}
				},
				"Grouping operator":{
					"function":"operators expressly evaluate grouping operand first",
					"notation":"(operand)"
				},
				"Commma operator":{
					"function":"operators expressly evaluate operands from left to right"
				}
			}
		},
		"Type conversion":{
			"implicit type conversion":{
				"function":"operator convert operad data type before execute operate",
				"type conversion rules":{
					"any data type to Boolean":{
						"falsy":{
							"conversion rule":"falsy value vonverted to false",
							"value of falsy":"false, undefined, null, 0, NaN, \"\""
						}
					},
					"any data type value other than falsy":"operator convert various data type value dependent on operator"
				}
			},
			"Explicit type conversion":{
				"to Boolean":{
					"Boolean constructor function":{
						"function":{
							"falsy value":"if orgument is falsy value, function return false",
							"not falsy value":"function return true"
						},
						"notation":"Boolean(orgument)"
					}
				},
				"to String":{
					"String constractor function ":{
						"from Primitive data type value":{
							"String data type value":"function return as it is",
							"true, false, null, undefined symbol":"return argument as string",
							"Synbol(exlain)":"return Synbol(exopain) as string"
						},
						"from object data type value":{
							"array":"return elemens => element, element, ・・・・",
							"object":"return [object object]",
							"function(){}":"return function(){}",
							"() => {}":"return () => {}"
						},
						"notation":"String(argument)"
					},
					"to Number":{
						"Number constructor function":{
							"parseInt":{
								"function":"return number as integer",
								"notation":"Number.parceInt(String, base number), base number is 10 or 8 or 2or 16"
							},
							"parseFloat":{
								"function":"return number as floating point number",
								"notation":"Number.parseFloat(String)"
							},
							"argument contain other than number":{
								"contain number":"ignore other than number, and return number",
								"do not contaion number":"return NaN"
							},
							"isNaN":{
								"function":"evaluate argument is Nan or not",
								"notation":"Number.isNaN(argument)"
							},
							"charactaristic of Nan":{
								"operation result":"if NaN is operand, any operator return NaN regardless other operand",
								"NaN is not mach itself":"=== operator evaluate NaN === NaN to false"
							}
						}
					}
				}
			}
		},
		"function and declaration":{
			"function object":{
				"function is a object that put together formulas or input/output":{
					"function has pre status and post status essentially":{},
					"function enable to contain operation target essentially":{}
				}
			},
			"dummy argument":{
				"dummy argument is operation target":{},
				"function":"contain argument value",
				"notation":"(argument, argument, argument, ..)",
				"assingnment argument value to dummy argument":{
					"argument is less than dummy argument":{
						"dummy argument do not have default argument":"remeinder dummy argument value is undefined",
						"dummy argument have default argument":"remeinder dummy argument value is default argument value",
						"default argument":{
							"notation:":"(dummy argument = default argument, dummy argument = default argument)",
							"alternate notation":"function function name(argument) {const arg = argument || default}",
							"important point of alternate notation":"if arugument is empty strign value, argument return default"
						}
					},
					"arguments are more than dummy argument":{
						"function ignore remeinder argument":{}
					},
					"variable arguments":{
						"rest parameters":{
							"notation":"(argument, ...rest parameters) rest parameters is end of arguments",
							"function":"restparameters has array of all remeinder arguments orderd by permutation"
						},
						"spred syntax":{
							"notation":"function(...array)",
							"function":"call operator spread array and store element to dummy arguments"
						},
						"arguments":{
							"arguments is specific variable onlu used in function":{
								"arguments is array-like object, but not Array":{
									"argument contain elements having index, and call by index like array":{
										"arguments do not have array method":{}
									}
								}
							},
							"notation":{
								"function fn() {x = arguments[0]}":{}
							}
						},
						"Destructuring assignment":{
							"object":{},
							"array":{}
						}
					}
				}
			},
			"function expression":{
				"function declaration":{
					"notation":"function function name(dummy argument, dummy argument, ..) {return return value}",
					"call with function name":{
						"notation":"function name(argumen, argument, ...)"
					}
				},
				"function formula":{
					"without function name":{
						"notation":"const variable = function() {}",
						"call function notation":"variable()",
						"function without function name is called annonymus function":{},
						"arrow function":{
							"notation":"const variable = () => {}",
							"elipsis":{
								"const variable = a argument => {}":{
									"elipisis ()":"if dummy argument is one, function do not need ()",
								"const variable = argument => argument * 2;":{
									"elipisis {} and return":"if function has only one formula, function do not need blocks and return, and return evaluation of formula"
								}
							}
						}
					},
					"with function name":{
							"const variable = function function name() {}":{
								"function name is valid only in the function":{
									"use":"recursive call in function"
								}
							}
						}
					}
				},
				"function declaration with same function name":{
					"override":"function name is overrided with last function"
				}
			},
			"call back function":{
				"function":{
					"call back function is argument, and is executed in caller function":{
						"caller function is nemed higher-order function":{},
						"exampele":"const array = [1, 2, 3]; const output = value => console.log(value); array.forEach(output);",
						"alterate notation of exampe":"const array = [1, 2, 3];, array.forEach(value => console.log(value););"
					}
				}
			},
			"method":{
				"method is function that is propaty value of object":{
					"notaion":"const obj = {method:()=>{}, otherpropaty:othervalue}"
				},
				"assingment function to propaty":{
					"alternate notation":"object.method = () => {};"
				},
				"call method":{
					"notation":"obj.method()"
				},
				"abbreviated notation":"const obj = {methodname(argument) {return argument;}, otherpropaty:othervalue}"
			}
		},
		"Statement and Expression":{
			"JavaScript is struvtured with Statements and Expressions":{},
			"Expression":{
				"function":{
					"evaluate and return evaluation value":{
						"expression evaluate statement itself and retrun evaluation value":{},
						" assignment operator can assign evaluation value to variable":{}
					}
				},
				"example":"literal value, set of operand and operator, function"
			},
			"Statement":{
				"step to process is named statement":{
					"one step is one statement":{}
				},
				"notation":"statement; statement end at semicolon",
				"example":{
					"if satement, for stetement":"if and for do not evaluate and do not return evaluation value",
					"expression statement":{
						"simple substance expression":"one step expression is one statement",
						"notation":"expression;"
					},
					"block stetement":{
						"block":{
							"function":"block put together multiple statements",
							"notation":"{} ,statement block statement do not need semicolon"
						},
						"notation":"if statement end at block, statement do not need semicolon"
					}
				}
			}

		},
		"conditional branch":{
			"condition":"condition is premitive recognition as same and different, that is expanded preposition and postposition",
			"if statement":{
				"single condition":{
					"notation":"if (boolean data type value) statement; , statement is usualy used block{}",
					"function":"if boolean data type value is true, if statement process postposition statement",
					"recognition":"that condition is true is preposition, and statement is postposition",
					"else statement":{
						"notation":"if (boolean data type value) {} else statement;, else need that notation that if () {} before else, if elipsis {} and postposition statement of true is used semicolon cleary supplement {}",
						"function":"if beelean data type is false, if statement process postposition else statement",
						"recognition":"that condition is false is preposition, and else statement is postposition"
					}
				},
				"common function":"postposition statement is nothing, if-statement do not process any statemens, not return preposition condition and branch to false",
				"multiple condition":{
					"use":"postposition statement is conditional branch",
					"if condition is false":{
						"else if statement":{
							"notation":"if(boolean) {} else if(boolean data type) statement; , {} is need same as else statement",
							"function":"if boolean data type value of else if is true, if statement process postposition statement",
							"recognition":"else statement is conditional branh",
							"attention point":"if else-statement is true and process statement, if-statement end, so that post else-statement or else-if-statement is not processed"
						}
					},
					"if condition is true":{
						"nested-if statement":{
							"notation":"if(boolean) if(boolean data type) statement;",
							"function":"if nested boolean data type value is true, if-statement process nested postposition statement",
							"recognition":"if statement is conditional branh",
							"attention point":"if statement is false, and postposition statement is nothing, if-statement end, so that do not return to preposition condition"
						}
					}
				}
			},
			"swich statement":{
				"recognition":"that two conditions are same is preposition, and statement is postposition",
				"notation":"switch (condition expression) {case expression: statement; break; case expression statement; break; default: statement; break; , swith statement neet block",
				"function":"switch-statement evaluate condition expression, and evaluate case expression, and evaluate with strict equal operator two evaluation value, if evaluate and return true, process case statement",
				"attention point":"if === oparator return true, switch-statement  do not evaluate next case expression, and process next case statement unconditionaly",
				"break statement":{
					"function":"end switch statement to include break",
					"notation":"break;"
				}
			}
		},
		"loop and iterative processing":{
			"recognition":"do same thing literatively",
			"while statement":{
				"recognition":"preposition condition is true, and process postposition statement iteratively, end that preposition condition is false",
				"alternate recognition":"do if-statement iteratively, end that condition of if-statement is false",
				"function":"while statement evaluate condition, if condition is true, process statement, and next while-statement iteratively, end that condition of if-statement is false",
				"notation":"while (condition expression) {statement;} , if while statement is elipsised {}, supplement {}, but end at ;",
				"attention point":"preposition condition of if-statement is always true, while-statement process if-statement unlimitedly"
			},
			"do-while statement":{
				"recognition":"process preposition statement, and postposition condition is true iteratively, end to postposition condition is false",
				"function":"while statement process statement, and evaluate condition, if condition is true, process next while-statement iteratively, end that condition of if-statement is false",
				"notation":"do {statement;} while (condition expression);",
				"attention point":"preposition condition of if-statement is always true, while-statement process if-statement unlimitedly"
			},
			"for statement":{
				"recognition":"preposition condition is true, and process postposition statement iteratively, end that preposition condition is false",
				"alternate recognition":"do if-statement iteratively, end that condition of if-statement is false or same as while statement",
				"notation":"for (initial expression; condition expression; inclemental expression) {statement;}",
				"function":"for statement evaluate condition, if condition is true, process statement, and process next for statement. next is that process inclemental expression, and evaluate condition expression , if condition is trut, process statement and next for statement iteratively, end that condition of if-statement is false",
				"attention point":"evaluation result of condition expression is always true, for-statement process for-statement unlimitedly"
			},
			"method of Array":{
				"forEach":{
					"function":{
						"forEach method is propaty value of Array object":"{Array object:{Array:[element, element, ...], forEach:method, ...}}",
						"forEach method assign element to dummy argument of callback-function and process function expression, process each element one by one, from index 0 to last index":{},
						"callback function":"callback function is function expression to be assigned to dymmy argument of function",
						"higher-order function":"higher-order function is function to assign callback function to dummy argument"
					},
					"notation":"const array = [1, 2, 3]; array.forEach(callback dummy argument => {statement;} , {} is need, but statement is one expression, able to elipsis {} without )"	
				},
				"some":{
					"function":{
						"some method is assign element to dummy argument of callback-function and process function expressoin, process each element one by one, from index 0 to last index ,to end that call-back function return true or end of elements":{
							"if call-back function return true":"some method return true and end",
							"if call-back function that its dummy argument assigned last element of array return false":"some method return false and end"
						}
					},
					"notation":"const array = [1,2,3]; array.some(x => {rerutn express})"
				},
				"filter":{
					"function":{
						"forEach method assign element, index, array to dummy argument of callback-function and process function expression, process each element one by one, from index 0 to last index, and return array":{
							"if callback function returned true":"assign element to array to be returned value"
						}
					}
				}			
			},
			"break statement":{
				"function":"end for or while or do-while statement ,to include break",
				"notation":"break;",
				"use":"while (condition){if(if condition){break;}};"
			},
			"continue statement":{
				"function":"end for or while or do-while statement, to include continue, and continue to process next while or do-while statement",
				"notation":"continue",
				"use":"while (condition){if(if condition){continue;}};"
			},
			"for...in statement":{
				"function":{
					"variable in for...in statement":" for...in statement assign object propaty to variable, and process statement iteratively till end to last propaty "
				},
				"notation":"for (variable in object) {statement;}",
				"use":"const obj = {a:1, b:2, c:3}; for (x in obj) {console.log(`x:${obj[x]}`);}"
			},
			"for...of statement":{
				"function":"for...of statement assign propaty value to variable and process statement iteratively till end to last propaty",
				"notation":"for (variable of iterable object){statement;}",
				"iterable object":{
					"definition":"iterable object is object to have iterable method",
					"iterable method":"iterable method is process to prosess iteratively",
					"example":"array abject, string object"
				}
			}
		},
		"object":{
			"recognition":{
				"object":"target to recognize as it is",
				"propatie":"element object to have, and be able to name element"
			},
			"function":{
				"object is set of properties":{
					"propateie":{
						"propatie is pair of key and value":{
							"recognition":{
								"key":"element name",
								"value":"element as it is"
							}
						}
					}
				}
			},
			"notation":{
				"object literal":"{}",
				"object":{
					"{key : value}":{
						"quote of propatie name is be able to elipsis":""
					}
				}
			}
		}
	}
}}